<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高级数据结构</title>
    <link href="/2022/03/10/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/03/10/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  学习过数据结构的同学，也许会好奇标准库里的实现。当你真的去看源码的时候，你会发现，写STL的大佬确实贼强。待你细细研究之后，若抛开泛型等复杂特性，你会发现其实我们所学的数据结构知识，是能帮助我们理解的。</p><p>  数组和链表，是我们学过的最基础的数据结构了，它们都属于线性表。我们发现其他的数据结构都可以用数组或者链表进行模拟，栈和队列显然可以，二叉树可以用数组或者二叉链表模拟，还可以用树状数组来模拟树。至于图，邻接矩阵和邻接表不也是可以用数组链表模拟嘛？（<del>我好像说了一大段废话</del>）</p><p>  所谓高级数据结构，其实现也无非是在这两者的组合。在此并不是想说它们很简单，反之，它们原理虽然不算难，但是却可以解决一些难题，对于一些直观上只能暴力解的问题，运用好高级数据结构可以更高效地解决它们。（<del>算了看题吧</del>）</p><h1 id="并查集">并查集</h1><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/friend-circles/">Leetcode-547.Friend Circles</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：There are <strong>N</strong> students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a <strong>direct</strong> friend of B, and B is a <strong>direct</strong> friend of C, then A is an <strong>indirect</strong> friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p><p>Given a **N*N<strong> matrix </strong>M<strong> representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are </strong>direct** friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p><p>题目大意：给定一个邻接矩阵M[][]，M[i][j]=1时表示i和j是朋友，问矩阵M中有多少个朋友圈子。（求M中连通分量数）</p><h3 id="并查集的实现">并查集的实现</h3><p>  求无向图的连通分量数显然可以使用<strong>并查集(UnionFind)</strong>，这是并查集的特点决定的。并查集类似于森林，每个结点可以是独立的，也可以指向其他的结点，森林中每棵树存在根结点或它本身。</p><p>  我们可以使用数组作为并查集的数据结构，数据下标代表元素，数组中存储的元素表示该元素指向的结点元素。</p><p>  并查集具有两个操作，1、合并结点（并）；2、查询两个结点是否处于同一个根结点之下（查）。根据以上信息，我们容易写出并查集的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span>&#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> count;             <span class="hljs-comment">//结点个数</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;    <span class="hljs-comment">//存储每个结点的父结点</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">UnionFind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>        parent = vector&lt;<span class="hljs-keyword">int</span>&gt;(count, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++ i)<br>            parent[i] = i;      <span class="hljs-comment">//  每个结点独立</span><br>    &#125;<br>    <span class="hljs-comment">// 查找p的根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-comment">// 递归查询</span><br>        <span class="hljs-keyword">if</span>(p != parent[p])<br>            parent[p] = <span class="hljs-built_in">find</span>(parent[p]);<br>        <span class="hljs-keyword">return</span> parent[p];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p) == <span class="hljs-built_in">find</span>(q);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionElements</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>&#123;<br><br>        <span class="hljs-keyword">int</span> pRoot = <span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-keyword">int</span> qRoot = <span class="hljs-built_in">fidn</span>(q);<br>        <span class="hljs-comment">// 已经合并的提前退出</span><br>        <span class="hljs-keyword">if</span>(pRoot == qRoot) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// p父结点指向q</span><br>        parent[pRoot] = q;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="并查集路径压缩优化">并查集路径压缩优化</h3><p>  显然上面的代码是正确的，但是我们考虑一种极端情况：如果每次合并都直接将p的父结点指向q，可能会出现一颗深度极深的树。如下：</p><p>  1 -&gt; 2 -&gt; 3 -&gt; ... -&gt; n</p><p>  当我们查询结点1的父结点时，需要经过n-1次递归查询，这增大了时间开销。</p><p>  优化的思路也非常简单，我们每次合并结点时，将结点指向最上层的父结点即可。我们称之为路径压缩。</p><p>  在这里增加一个新的数组rank[]，它记录每个结点在对应树中的层数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">int</span> count;            <span class="hljs-comment">//结点数</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; parent;   <span class="hljs-comment">//存储每个结点的父结点</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; rank;     <span class="hljs-comment">//每个结点在树中的层度</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">UnionFind</span>(<span class="hljs-keyword">int</span> count)&#123;<br>        <span class="hljs-keyword">this</span>-&gt;count = count;<br>        parent = vector&lt;<span class="hljs-keyword">int</span>&gt;(count, <span class="hljs-number">0</span>);<br>        rank = vector&lt;<span class="hljs-keyword">int</span>&gt;(count, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; ++ i)&#123;<br>            parent[i] = i;<br>            rank[i] = <span class="hljs-number">1</span>;    <span class="hljs-comment">//rank[]初始值为1</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span></span>&#123;<br>        <span class="hljs-comment">//递归查询</span><br>        <span class="hljs-keyword">if</span>(p != parent[p])&#123;<br>            parent[p] = <span class="hljs-built_in">find</span>(parent[p]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parent[p];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(p) == <span class="hljs-built_in">find</span>(q);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unionElements</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> pRoot = <span class="hljs-built_in">find</span>(p);<br>        <span class="hljs-keyword">int</span> qRoot = <span class="hljs-built_in">find</span>(q);<br>        <span class="hljs-keyword">if</span>(qRoot == pRoot)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//合并结点时指向rank较大的 即小集合合并到大集合</span><br>        <span class="hljs-keyword">if</span>(rank[pRoot] &lt; rank[qRoot])<br>            parent[pRoot] = qRoot;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[qRoot] &lt; rank[pRoot])<br>            parent[qRoot] = pRoot;<br>        <span class="hljs-keyword">else</span>&#123;<br>            parent[pRoot] = qRoot;<br>            rank[qRoot] += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="ac代码">AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCircleNum</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = M.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">UnionFind <span class="hljs-title">uf</span><span class="hljs-params">(n)</span></span>; <span class="hljs-comment">//调用上面的UnionFind代码</span><br>        <span class="hljs-comment">// 构建并查集</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++ j)&#123;<br>                <span class="hljs-keyword">if</span>(M[i][j])&#123;<br>                    uf.<span class="hljs-built_in">unionElements</span>(i, j);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 使用STL中的set挑出不重复的元素</span><br>        <span class="hljs-comment">// set个数即连通分量树</span><br>        set&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++ i)&#123;<br>            st.<span class="hljs-built_in">insert</span>(uf.<span class="hljs-built_in">find</span>(i));<br>        &#125;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="并查集简单实现">并查集简单实现</h2><p>  用于快速写题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> father[N], n;<br><br><span class="hljs-comment">// 初始化，每个节点的父节点是自己</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; N; ++ i)&#123;<br>        father[i] = i;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找x节点的根节点</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> a = father[x]; <span class="hljs-comment">// 暂存a的父节点</span><br><br>    <span class="hljs-keyword">while</span>(x != father[x])&#123;<br>        x = father[x]; <span class="hljs-comment">// 逐层向上查找</span><br>    &#125;<br><br>    <span class="hljs-comment">// 路径压缩</span><br>    <span class="hljs-comment">// 将x原来的父节点到根节点的所有节点，都指向根节点</span><br>    <span class="hljs-keyword">while</span>(a != father[a])&#123;<br>        <span class="hljs-keyword">int</span> t = father[a];<br>        father[a] = father[x];<br>        a = t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> father[x]; <span class="hljs-comment">// 返回根节点</span><br>&#125;<br><br><span class="hljs-comment">// 合并两个节点</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> fa = <span class="hljs-built_in">find</span>(a), fb = <span class="hljs-built_in">find</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(fa != fb)&#123;<br>            father[fa] = fb; <span class="hljs-comment">// a的根节点指向b的根节点</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查看两个节点是否在同一个集合/连通分量中</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isConnect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(a) == <span class="hljs-built_in">find</span>(b);<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>  进阶：带权并查集</p><h1 id="trie">Trie</h1><p>题目来源：<a href="https://leetcode.com/problems/implement-trie-prefix-tree/">Leetcode-208.Implement Trie (Prefix Tree)</a></p><p>题目描述：Implement a trie with <code>insert</code>, <code>search</code>, and <code>startsWith</code> methods.</p><p>题目样例：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp">Trie trie = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br><br>trie.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;apple&quot;</span>);<br>trie.<span class="hljs-built_in">search</span>(<span class="hljs-string">&quot;apple&quot;</span>);   <span class="hljs-comment">// returns true</span><br>trie.<span class="hljs-built_in">search</span>(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// returns false</span><br>trie.<span class="hljs-built_in">startsWith</span>(<span class="hljs-string">&quot;app&quot;</span>); <span class="hljs-comment">// returns true</span><br>trie.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;app&quot;</span>);   <br>trie.<span class="hljs-built_in">search</span>(<span class="hljs-string">&quot;app&quot;</span>);     <span class="hljs-comment">// returns true</span><br></code></pre></div></td></tr></table></figure><p>题目大意：查找某个字母组合是否为某单词的前缀。</p><p>  解析：在词组中查找前缀/某个词，如果用暴搜，这个复杂度能达到<span class="math inline">\(O(MN)\)</span>，肯定是不行的。</p><p>  <em>线段树</em>为了加速搜索，使用空间换时间。在每个结点存储下一个字母的地址（这个定义是递归的）。用unordered_map或者数组都可以实现。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TrieNode</span>&#123;</span><br>    <span class="hljs-keyword">bool</span> isword;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>,TrieNode*&gt;next;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">TrieNode</span><span class="hljs-params">()</span>:isword(false)&#123;</span><br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    TrieNode * root;<br>    <span class="hljs-keyword">int</span> size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">Trie</span>() &#123;<br>        root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Inserts a word into the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ch: word)&#123;<br>            <span class="hljs-keyword">if</span>(! p-&gt;next[ch])&#123;<br>                p-&gt;next[ch] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>            &#125;<br>            p = p-&gt;next[ch];<br>        &#125;<br>        p-&gt;isword = <span class="hljs-literal">true</span>;<br>        ++ size;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if the word is in the trie. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(string word)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ch: word)&#123;<br>            <span class="hljs-keyword">if</span>(! p-&gt;next[ch])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;next[ch];<br>        &#125;<br>        <span class="hljs-keyword">return</span> p-&gt;isword;<br>    &#125;<br>    <br>    <span class="hljs-comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(string prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> p = root;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;ch: prefix)&#123;<br>            <span class="hljs-keyword">if</span>(! p-&gt;next[ch])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            p = p-&gt;next[ch];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your Trie object will be instantiated and called as such:</span><br><span class="hljs-comment"> * Trie obj = new Trie();</span><br><span class="hljs-comment"> * obj.insert(word);</span><br><span class="hljs-comment"> * bool param_2 = obj.search(word);</span><br><span class="hljs-comment"> * bool param_3 = obj.startsWith(prefix);</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><h1 id="线段树">线段树</h1>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>线段树</tag>
      
      <tag>Trie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划简单总结</title>
    <link href="/2022/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的动态规划题，当年写的时候真的老费劲了，也没有总结模型和技巧。碰到求最、恰好等等的题目，首先可以判断是否可以贪心，如果不行那可能只能动态规划了。</p><p>  动态规划（DP）的本质是什么？从各种算法书中可以了解到，<em>动态规划实际上是对有向无环图（DAG）的广度优先遍历（BFS）</em>。对于初学者而言，虽然我们知道DAG，也知道BFS，但是这个「本质」还是太抽象了，这里我们暂且不讨论。</p><p>  那么如何学好DP呢？由于我本人也是人菜瘾大，所以我还是选择听从各路大神的建议。</p><p>  首先，我们需要知道DP有哪些模型。</p><ul><li>数字三角形</li><li>最长上升子序列</li><li>背包DP</li><li>树状DP</li><li>状态机DP</li><li>状态压缩DP</li><li>区间DP</li><li>数位DP</li><li>斜率优化DP</li><li>单调队列优化DP</li></ul><p>  然后，找模板题，训练。这里需要熟知每一种模板的代码，达到盲打程度即可。（推荐<a href="https://www.acwing.com/">AcWing</a>，y总YYDS！）</p><p>  最后，刷题+总结。碰到题目先判断下可能用到哪种DP模型，然后再对应上去。这个过程极其艰辛。</p><p>下面列一下LC上的题。</p><h1 id="数字三角形">数字三角形</h1><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/triangle/">Leetcode-120.Triangle</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>样例：</p><p>For example, given the following triangle</p><p>[ [<strong>2</strong>], [<strong>3</strong>,4], [6,<strong>5</strong>,7], [4,<strong>1</strong>,8,3]]</p><p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p><p><strong>Note:</strong></p><p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p><p>题目大意：给定一个三角矩阵，选择一条自顶向下的路径，使得该路径经过的数字只和最小。注意，每往下走一步，只能走到相邻的格子。</p><h3 id="状态转移">状态转移</h3><p>  将该矩阵作为记忆化搜索的存储矩阵，从上往下、逐行遍历，每个元素选择上一行最小相邻元素相加，然后遍历最后一行元素取出最小值即可。</p><h3 id="代码">代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-comment">// 从第二行开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j)&#123;<br>            <span class="hljs-comment">// 第二行单独处理 因为第一行只有一个元素            </span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                triangle[i][j] += triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-comment">// 每行第一个元素单独处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-comment">// 每行最后一个元素也单独处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == triangle[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 其余元素有前驱也有后继</span><br>            <span class="hljs-comment">// 选择最小值相加</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &lt; triangle[i - <span class="hljs-number">1</span>][j] ? triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] : triangle[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历最后一行 取出最小值</span><br>    <span class="hljs-keyword">int</span> minx = triangle[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; triangle[n - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); ++k)&#123;<br>        <span class="hljs-keyword">if</span>(minx &gt; triangle[n - <span class="hljs-number">1</span>][k])<br>            minx = triangle[n - <span class="hljs-number">1</span>][k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> minx;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练">相关训练：</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/climbing-stairs/">Leetcode-70.Climbing Stairs</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/070-climbing-stairs/climbing-stairs.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Adobe</strong>；<strong>Apple</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/minimum-path-sum/">Leetcode-64.Minimum Path Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/064-minimum-path-sum/minimum-path-sum.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="记忆化搜索">记忆化搜索</h1><p>  有时候「记忆化搜索」比DP更容易想到，因为状态转移方程不容易推导。</p><h2 id="题目-1">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/integer-break/">Leetcode-343.Integer Break</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>样例1：</p><p><strong>Input:</strong> <code>2</code></p><p><strong>Output:</strong> <code>1</code></p><p><strong>Explanation:</strong> 2 = 1 + 1, 1 × 1 = 1.</p><p>样例2：</p><p><strong>Input:</strong> <code>10</code></p><p><strong>Output:</strong> <code>36</code></p><p><strong>Explanation:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</p><p><strong>Note</strong>: You may assume that <em>n</em> is not less than 2 and not larger than 58.</p><p>题目大意：对一个正整数进行分割，获取分割后整数乘积的最大值。注意至少分割两次，至多不超过58次。</p><h3 id="解析">解析</h3><p>  这个问题可以找到<strong>最优子结构</strong>，考虑整数n的情况，若已知n-1的最优结果，则可以求出n的最优结果，当n=1时整数无法再继续分割（递归终止）。同时使用记忆化搜索对分割结果进行保存。</p><h3 id="实现代码">实现代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a, <span class="hljs-built_in">max</span>(b, c));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(vec[n] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> vec[n];<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; ++ i)<br>            <span class="hljs-comment">// 保存最大值</span><br>            ret = <span class="hljs-built_in">max3</span>(ret, i * (n - i), i * <span class="hljs-built_in">dp</span>(n - i));<br>        vec[n] = ret;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(n);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-1">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/perfect-squares/">Leetcode-279.Perfect Squares</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/279-perfect-squares/perfect-squares.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/decode-ways/">Leetcode-91.Decode Ways</a></td><td><a href="#Leetcode-91">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Uber</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/unique-paths/">Leetcode-62.Unique Paths</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/062-unique-paths/unique-paths.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/unique-paths-ii/">Leetcode-63.Unique Paths II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/063-unique-paths-ii/unique-paths-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr></tbody></table><div id="Leetcode-91"></div><p>Leetcode-91 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i)&#123;<br>            <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> || s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    dp[i] = dp[i - <span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">else</span><br>                    dp[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                dp[i] = ((s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>)) ? dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] : dp[i - <span class="hljs-number">1</span>];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="状态机模型">状态机模型</h1><h2 id="题目-2">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/house-robber/">Leetcode-198.House Robber</a></p><p><strong>Linkedin</strong>；<strong>Airbnb</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><p>样例1：</p><p><strong>Input:</strong> <code>[1,2,3,1]</code></p><p><strong>Output:</strong> <code>4</code></p><p><strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</p><p>样例2：</p><p><strong>Input:</strong> <code>[2,7,9,3,1]</code></p><p><strong>Output:</strong> <code>12</code></p><p><strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.</p><p>题目大意：给定数组nums，根据选取元素不能相邻的原则选出和为最大值的组合，求出这个最大值。</p><p>题目解析：给定数组nums[0,...,n - 1]，若第一次选择nums[0]，则下一步需要考虑nums[2,...,n - 1]；若选择的是nums[1]，则下一步考虑nums[3,...,n - 1]……</p><h2 id="状态定义">状态定义</h2><p>对函数的定义，考虑选择nums[i, ..., n - 1]</p><h2 id="状态转移-1">状态转移</h2><p><span class="math inline">\(F(0) = max(nums[0] + F(2), nums[1] + F(3),...，nums[n - 3] + F(n - 1), nums[n - 2], nums[n - 1])\)</span></p><h3 id="代码1">代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> pos)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pos &gt;= nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dp[pos] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> dp[pos];<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 范围是nums[pos, ..., nums.size() - 1]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = pos; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            ret = <span class="hljs-built_in">max</span>(ret, nums[i] + <span class="hljs-built_in">help</span>(nums,i + <span class="hljs-number">2</span>));<br>        dp[pos] = ret;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">help</span>(nums, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="代码2">代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        dp[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; n ; ++j)<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], nums[j] + ( j + <span class="hljs-number">2</span> &lt; n ? dp[j + <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-2">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/house-robber-ii/">Leetcode-213.House Robber II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/213-house-robber-ii/house-robber-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Microsoft</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/house-robber-iii/">Leetcode-337.House Robber III</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/337-house-robber-iii/house-robber-iii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Uber</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Leetcode-309.Best Time to Buy and Sell Stock with Cooldown</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown/best-time-to-buy-and-sell-stock-with-cooldown.cpp">Solution-C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr></tbody></table><h1 id="背包模型">背包模型</h1><h2 id="背包">01背包</h2><p>  假设背包容量为<span class="math inline">\(C\)</span>，给定有限个物品序列<span class="math inline">\(w[w_0,...,w_{n - 1}]\)</span>，每个物品具有对应的价值<span class="math inline">\(v[v_0, ..., v_{n - 1}]\)</span>，可以选择放入背包或者不放入，找出使得放入背包后物品价值总和为最大值的组合，求出这个最大值。</p><h3 id="实现1">实现1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(C*n)</span><br><span class="hljs-comment">// memory: O(C*n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;w, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = w.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 使用二维数组存储搜索结果</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(C + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>    <span class="hljs-comment">// 初始化第一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>        dp[<span class="hljs-number">0</span>][j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>            <span class="hljs-comment">// 选择不放入</span><br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 若容量允许 选择放入</span><br>            <span class="hljs-comment">// 求出两种策略的最大值</span><br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后一行最后一个元素即所求最大值</span><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][C];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实现2">实现2</h3><p>  时间复杂度为<span class="math inline">\(O(Cn)\)</span>无法优化，但是可以优化空间复杂度。方法：滚动数组/一维。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(C*n)</span><br><span class="hljs-comment">// memory: O(C)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;w, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = w.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 使用一维数组存储</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(C + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-comment">// 初始化“第一行“</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>        dp[j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-comment">// 这里每行是从后往前搜索</span><br>        <span class="hljs-comment">// 先更新后面的元素是因为计算时要用到前面的元素，切记</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = C; j &gt;= w[i]; -- j)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个元素为最大值</span><br>    <span class="hljs-keyword">return</span> dp[C];<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="题目2">题目2</h2><p>问题来源：<a href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode-416.Partition Equal Subset Sum</a></p><p><strong>Ebay</strong></p><p>问题难度：<strong>Medium</strong></p><p>问题描述：Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol type="1"><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p>样例1：</p><p><strong>Input</strong>: <code>[1, 5, 11, 5]</code></p><p><strong>Output</strong>: <code>true</code></p><p><strong>Explanation</strong>: The array can be partitioned as [1, 5, 5] and [11].</p><p>样例2：</p><p><strong>Input</strong>: <code>[1, 2, 3, 5]</code></p><p><strong>Output</strong>: <code>false</code></p><p><strong>Explanation</strong>: The array cannot be partitioned into equal sum subsets.</p><p>问题大意：给定n个数字，它们的和为sum，选出一定物品使得容量为sum/2</p><h3 id="实现代码-1">实现代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; num: nums) sum += num;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), C = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(C + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)<br>            dp[j] = (nums[<span class="hljs-number">0</span>] == j);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = C; j &gt;= nums[i]; -- j)&#123;<br>                <span class="hljs-comment">// 不使用或使用nums[i]</span><br>                dp[j] = dp[j] || dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[C];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-3">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/coin-change/">Leetcode-322.Coin Change</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/322-coin-change/coin-change.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/combination-sum-iv/">Leetcode-377.Combination Sum IV</a></td><td><a href="#Leetcode-377">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Google</strong>；<strong>Snapchat</strong></td></tr><tr class="odd"><td><a href="%5BOnes%20and%20Zeroes%5D(https://leetcode-cn.com/problems/ones-and-zeroes/)">Leetcode-474.Ones and Zeros</a></td><td></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/word-break/">Leetcode-139.Word Break</a></td><td></td><td><strong>Medium</strong></td><td><strong>Google</strong>；<strong>Facebook</strong>;<strong>Amazon</strong>;<strong>Uber</strong>;<strong>Bloomberg</strong>;<strong>PocketGems</strong>;<strong>Yahoo</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/target-sum/">Leetcode-494.Target Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/494-target-sum/target-sum.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong>；<strong>Facebook</strong></td></tr></tbody></table><div id="Leetcode-377"></div><p>Leetcode-377 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target + <span class="hljs-number">1</span>; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt;= i)<br>                    dp[i] = dp[i] + dp[i - nums[j]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="最长上升子序列模型">最长上升子序列模型</h1><h2 id="题目-3">题目</h2><p>问题来源：<a href="https://leetcode.com/problems/longest-increasing-subsequence/">Leetcode-300.Longest Increasing Subsequence</a></p><p><strong>Microsoft</strong></p><p>问题难度：<strong>Medium</strong></p><p>问题描述：Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>样例：</p><p><strong>Input:</strong> <code>[10,9,2,5,3,7,101,18]</code></p><p><strong>Output:</strong> <code>4</code></p><p><strong>Explanation:</strong> The longest increasing subsequence is <code>[2,3,7,101]</code>, therefore the length is <code>4</code>.</p><p>问题大意：给定一个整数序列nums[], 求出其中最长上升子序列的长度。</p><h3 id="解析-1">解析：</h3><p><strong>最长上升子序列</strong>（<strong>LIS</strong>）问题。设置状态<em>LIS(i)</em>为第i个数字为结尾的最长上升子序列的长度。那么<em>LIS(i)</em>表示nums[0, ..., i]内，选择nums[i]可以获得的最长上升子序列的长度。</p><h3 id="状态转移方程">状态转移方程</h3><p><span class="math inline">\(f[i] = max(f[j] + 1 {\,} if{\,}j &lt; i{\,}and{\,}nums[i] &gt; nums[j], f[i])\)</span></p><h3 id="代码1-1">代码1:</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 每个单独序列本身长度为1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; -- j)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    maxn = <span class="hljs-built_in">max</span>(dp[i], maxn);<br>                    <span class="hljs-comment">// 这一步的搜索必须将前面的数字都扫描一遍</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="代码2-1">代码2:</h3><p>  设置一个最长子序列dp[]，遍历nums[]，若nums[i]大于dp[]最后一个元素则末尾添加，否则在dp[]中找到适合nums[i]插入的位置，使得nums[i]替换刚好比它大的dp[j]。dp的长度即最长子序列的长度。</p><p>  由于dp是有序的，所以可以使用二分查找法。并且插入操作实际上是替换，所以总的时间复杂度为<em>O(nlogn)</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">if</span>(dp[len - <span class="hljs-number">1</span>] &lt; nums[i])&#123;<br>                dp[len ++] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// lower_bound最好自己实现一下.</span><br>                <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">begin</span>() + len, nums[i]);<br>                * it = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-4">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/wiggle-subsequence/">Leetcode-376.Wiggle Subsequence</a></td><td></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h2 id="题目2-1">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode-1143.Longest Common Subsequence</a></p><p>题目难度：Medium</p><p>题目描述：Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p><p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p><p>If there is no common subsequence, return 0.</p><p>样例1：</p><p><strong>Input:</strong> text1 = "abcde", text2 = "ace"</p><p><strong>Output:</strong> 3</p><p><strong>Explanation:</strong> The longest common subsequence is "ace" and its length is 3.</p><p>样例2：</p><p><strong>Input:</strong> text1 = "abc", text2 = "abc"</p><p><strong>Output:</strong> 3</p><p><strong>Explanation:</strong> The longest common subsequence is "abc" and its length is 3.</p><p>样例3：</p><p><strong>Input:</strong> text1 = "abc", text2 = "def"</p><p><strong>Output:</strong> 0</p><p><strong>Explanation:</strong> There is no such common subsequence, so the result is 0.</p><p>题目大意：给定两个字符串s1和s2，求出它们的最长公共字串的长度。</p><h3 id="解析-2">解析</h3><p>  这是一道动态规划的经典问题，我们可以定义状态<strong>LCS(i, j)</strong>, i表示s1的索引，j表示s2的索引。LCS存储的是s1[0,...,i - 1]和s2[0, ..., j - 1]的最长公共字串的长度。状态转移方程如下：</p><p><span class="math display">\[LCS(i,j)=\begin{cases}LCS(i - 1, j - 1)\:, if\:s1[i] == s2[i] \\max(LCS(i - 1, j)\:, LCS(i, j - 1)),if\:s1[i] != s2[j]\end{cases}\]</span></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string &amp;text1, <span class="hljs-keyword">const</span> string &amp;text2)</span></span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 这里要从1开始 因为初始为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.<span class="hljs-built_in">size</span>(); ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;item: dp)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; it: item)&#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, it);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode-5.Longest Palindromic Substring</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p>样例1：</p><p><strong>Input:</strong> <code>"babad"</code></p><p><strong>Output:</strong> <code>"bab"</code></p><p><strong>Note:</strong> "aba" is also a valid answer.</p><p>样例2：</p><p><strong>Input:</strong> <code>"cbbd"</code></p><p><strong>Output:</strong> <code>"bb"</code></p><p>题目大意：给定一个字符串s，求出该字符串的最长回文字串。</p><h3 id="状态定义-1">状态定义</h3><p>定义状态<em>dp(i，j)</em> ，表示子串s[i，j]是否为回文串，值为True时为回文串。</p><h3 id="状态转移方程-1">状态转移方程</h3><p><span class="math display">\[dp(i, j)=\begin{cases}True, s[i]==s[j]) \\s[i] == s[j], i == j + 1 \\s[i] == s[j]\:and\:dp(j + 1,i-1)\end{cases}\]</span></p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><span class="hljs-comment">// Leetcode耗时400ms</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), vector&lt;<span class="hljs-keyword">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(s.begin(), s.begin() + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; ++ i)&#123;<br>                dp[i][j] = s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>())&#123;<br>                    res = <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>数字三角形</tag>
      
      <tag>背包问题</tag>
      
      <tag>最长上升子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找问题</title>
    <link href="/2022/03/09/%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/09/%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的一些查找类型的题目。</p><h1 id="滑动窗口">滑动窗口</h1><p>  滑动窗口的核心是维护长度一定的区间（窗口），窗口向前滑动时，只需修改少量信息。通常能将时间复杂度降低至<span class="math inline">\(O(n)\)</span>，从而提高查找效率。</p><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/contains-duplicate-ii/">Leetcode-219.Contains Duplicate II</a></p><p><strong>Airbnb</strong>；<strong>Palantir</strong></p><p>题目描述：Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em>in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p><p>样例1：</p><p><strong>Input:</strong> nums = [1,2,3,1], k = 3</p><p><strong>Output:</strong> true</p><p>样例2：</p><p><strong>Input:</strong> nums = [1,0,1,1], k = 1</p><p><strong>Output:</strong> true</p><p>样例3：</p><p><strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2</p><p><strong>Output:</strong> false</p><p>题目大意：给定数组nums，找到nums[i] == nums[j]，索引i和j的差值不超过k。</p><h3 id="滑动窗口哈希表">滑动窗口+哈希表</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(k)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(nums[i]) != st.<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>() == k + <span class="hljs-number">1</span>)<br>                st.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/contains-duplicate/">Leetcode-217.Contains Duplicate</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/217-contains-duplicate/contains-duplicate.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Airbnb</strong>；<strong>Palantir</strong>；<strong>Yahoo</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/contains-duplicate-iii/">Leetcode-220.Contains Duplicate III</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/220-contains-duplicate-iii/contains-duplicate-iii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Airbnb</strong>；<strong>Palantir</strong></td></tr></tbody></table><h1 id="双指针">双指针</h1><p>  显然，用一个指针可以遍历线性表。但是为了解决一些问题，有时候可以考虑「双指针」，代码的实现更高效。</p><div id="Leetcode-167"></div><h2 id="题目1">题目1</h2><p>题目来源：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode-167.Two Sum II - Input array is sorted</a></p><p><strong>Amazon</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p>题目大意：给定有序数组numbers[]和整数target，在numbers[]中寻找两个数使其和为target，并返回这两个数的索引。</p><p>样例：</p><p><strong>Input:</strong> numbers = <code>[2,7,11,15]</code>, target = <code>9</code></p><p><strong>Output:</strong> <code>[1,2]</code></p><p><strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</p><h3 id="暴力解法">暴力解法</h3><p>  实在想不出更高效的解法时，可以考虑暴力解法。其实很多优化也是从暴力开始进行的。</p><p>  时间复杂度为<span class="math inline">\(O(n^2)\)</span>，Leetcode提交超时。</p><h3 id="双指针-1">双指针</h3><p>  由于这是一个有序数组，所以可以使用两个指针index1和index2，一首一尾，根据此时指向元素的求和情况改变指针的指向。若numbers[index1] + numbers[index2] &lt; target，则index1++；大于则index2--；等于则有解。当index1与index2相遇时仍没有解则无解。</p><p>  需要注意的问题：不能返回相同的索引；要处理没有解的情况；若多解该如何处理？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time:O(n)</span><br><span class="hljs-comment">// memory:O(1)</span><br><span class="hljs-comment">// 充分利用numbers[]有序的特征</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vt;<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>,index2 = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index1 &lt; index2)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[index1] + numbers[index2] == target)&#123;<br>                vt.<span class="hljs-built_in">push_back</span>(index1 + <span class="hljs-number">1</span>);<br>                vt.<span class="hljs-built_in">push_back</span>(index2 + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[index1] + numbers[index2] &gt; target)&#123;<br>                -- index2;<br>            &#125;<br>            <span class="hljs-keyword">else</span> ++ index1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-1">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/valid-palindrome/">Leetcode-125.Valid Palindrome</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/125-valid-palindrome/valid-palindrome.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Uber</strong>；<strong>Zenefits</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/reverse-string/">Leetcode-344.Reverse String</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/344-reverse-string/reverse-string.cpp">C++</a></td><td><strong>Easy</strong></td><td></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Leetcode-345.Reverse Vowels of a String</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/345-reverse-vowels-of-a-string/reverse-vowels-of-a-string.java">Java</a></td><td><strong>Easy</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode-11.Container With Most Water</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/011-container-with-most-water/container-with-most-water.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr></tbody></table><h2 id="题目2">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/two-sum/">Leetcode-1. Two Sum</a></p><p><strong>Facebook</strong>；<strong>Uber</strong>；<strong>Linkedin</strong>；<strong>Apple</strong>；<strong>Amazon</strong>；<strong>Microsoft</strong>；</p><p><strong>Yahoo</strong>；<strong>Yelp</strong>；<strong>Airbnb</strong>；<strong>Dropbox</strong>；<strong>Bloomberg</strong>；<strong>Adobe</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em>element twice.</p><p>样例：</p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9, return [<strong>0</strong>, <strong>1</strong>].</p><h3 id="暴力解法-1">暴力解法</h3><p>  双重循环，时间复杂度为<span class="math inline">\(O(n^2)\)</span>。提交超时。</p><h3 id="排序双指针">排序+双指针</h3><p>  先对数组nums按照索引进行排序，然后使用「双指针」。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p1, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> p1.second &lt; p2.second;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++ i)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i, nums[i]));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">int</span> idx1 = <span class="hljs-number">0</span>, idx2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(idx1 &lt; idx2)&#123;<br>            <span class="hljs-keyword">if</span>(vec[idx1].second + vec[idx2].second == target)&#123;<br>                res[<span class="hljs-number">0</span>] = vec[idx1].first;<br>                res[<span class="hljs-number">1</span>] = vec[idx2].first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vec[idx1].second + vec[idx2].second &gt; target)<br>                -- idx2;<br>            <span class="hljs-keyword">else</span><br>                ++ idx1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/minimum-size-subarray-sum/">Leetcode-209.Minimum Size Subarray Sum</a></p><p><strong>Facebook</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given an array of <strong>n</strong> positive integers and a positive integer <strong>s</strong>, find the minimal length of a <strong>contiguous</strong> subarray of which the sum ≥ <strong>s</strong>. If there isn't one, return 0 instead.</p><p>题目解析：给定有序整型数组nums[]和整数s，求出nums[]中最短的一个连续子数组，使得该子数组的和大于等于s。返回该子数组的元素个数。</p><p>样例：</p><p><strong>Input:</strong> <code>s = 7, nums = [2,3,1,2,4,3]</code></p><p><strong>Output:</strong> <code>2</code> <strong>Explanation:</strong> the subarray <code>[4,3]</code> has the minimal length under the problem constraint.</p><h3 id="子数组">子数组</h3><p>  通常情况下，子数组可以是不连续的。本题特别要求是连续的。</p><p>  无解的情况下，可以返回0或者规定的值。</p><p>  多解的情况下，子数组有多个，根据题意返回。</p><h3 id="暴力解法-2">暴力解法</h3><p>  遍历所有字数组，计算和sum，使得sum&gt;=s</p><p>  时间复杂度：<span class="math inline">\(O(n^3)\)</span>。可以优化为<span class="math inline">\(O(n^2)\)</span>。</p><p>  暴力解法中包含有大量重复计算。</p><h3 id="双指针滑动窗口">双指针+滑动窗口</h3><p>  本题可以使用双指针。值得注意的是，两个索引在数组中构成了「<strong>滑动窗口</strong>」，我们可以对这个窗口进行求和。如果索引发生了变化，新窗口的求和是可以在旧窗口的和上直接操作，加上或者减去对应索引的值即可。这里解决了暴力解法中重复计算的问题。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;         <span class="hljs-comment">// 初始窗口不包含任何值</span><br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> res = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>; <span class="hljs-comment">// 初始返回值比nums个数大，求min</span><br>        <span class="hljs-keyword">while</span>(l &lt; nums.<span class="hljs-built_in">size</span>())&#123;    <span class="hljs-comment">// 左边界l在范围内</span><br>            <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; nums.<span class="hljs-built_in">size</span>() &amp;&amp; sum &lt; s)<br>                sum += nums[++ r];<br>            <span class="hljs-keyword">else</span><br>                sum -= nums[l ++];<br>            <span class="hljs-keyword">if</span>(sum &gt;= s)&#123;<br>                res = <span class="hljs-built_in">min</span>(res, r - l + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 若res值没有更新，说明无解，返回0</span><br>        <span class="hljs-keyword">return</span> res == nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目4">题目4</h2><p>题目来源：<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Leetcode-3.Longest Substring Without Repeating Characters</a></p><p><strong>Amazon</strong>；<strong>Adobe</strong>；<strong>Yelp</strong>；<strong>Bloomberg</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p>样例1:</p><p><strong>Input:</strong> <code>"abcabcbb"</code></p><p><strong>Output:</strong> <code>3</code></p><p><strong>Explanation:</strong> The answer is <code>"abc"</code>, with the length of 3.</p><p>样例2:</p><p><strong>Input:</strong> <code>"bbbbb"</code></p><p><strong>Output:</strong> <code>1</code>                                        <strong>Explanation:</strong> The answer is <code>"b"</code>, with the length of 1.</p><p>样例3:</p><p><strong>Input:</strong> <code>"pwwkew"</code></p><p><strong>Output:</strong> <code>3</code></p><p><strong>Explanation:</strong> The answer is <code>"wke"</code>, with the length of 3.</p><p>Note that the answer must be a <strong>substring</strong>, <code>"pwke"</code> is a <em>subsequence</em> and not a substring.</p><p>题目大意：给定一个字符串s，找出没有重复字母的最长子串。</p><h6 id="暴力解法-3">暴力解法</h6><p>  朴素的思想：双重循环+STL中的set&lt;&gt;验证重复字符</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-keyword">char</span>&gt; set1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; s.<span class="hljs-built_in">size</span>(); i ++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i;j &lt; s.<span class="hljs-built_in">size</span>(); j ++)&#123;<br>                cnt ++;<br>                set1.<span class="hljs-built_in">insert</span>(s[j]);<br><br>                <span class="hljs-keyword">if</span>(set1.<span class="hljs-built_in">size</span>() != cnt)&#123;<br>                    cnt = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">if</span>(set1.<span class="hljs-built_in">size</span>() &gt;= maxn) maxn = set1.<span class="hljs-built_in">size</span>();<br>                    set1.<span class="hljs-built_in">clear</span>();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="滑动窗口双指针">滑动窗口+双指针</h3><p>  假定目前的字串是s[i,...,j]，当前s[i,...,j]没有重复字符，考虑s[j + 1]加入s[i,...,j]后的情况，若加入后仍没有重复字符，则新字串为s[i,...,j+1]；否则需要记录当前字串长度，考虑剔除s[i]及其后面字符的情况，使得加入s[j + 1]后仍保持不重复。</p><p>  技巧：新增一个数组freq[]，记录s[i,...,j]中每个字符的个数，以此判断s[i,...,j]中字符是否重复。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-comment">// 尽管使用了frep[256]，但元素个数是常数，故空间复杂度仍为O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> freq[<span class="hljs-number">256</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(r + <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !freq[s[r+<span class="hljs-number">1</span>]])<br>                ++freq[s[++r]];<br>            <span class="hljs-keyword">else</span><br>                --freq[s[l++]];<br>            res = <span class="hljs-built_in">max</span>(res,r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-2">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">Leetcode-438.Find All Anagrams in a String</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/438-find-all-anagrams-in-a-string/find-all-anagrams-in-a-string.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Amazon</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/minimum-window-substring/">Leetcode-76.Minimum Window Substring</a></td><td></td><td><strong>Hard</strong></td><td><strong>Facebook</strong>；<strong>Linkedin</strong>；<strong>Uber</strong>；<strong>Snapchat</strong></td></tr></tbody></table><h1 id="二分查找">二分查找</h1><p>  刚才的题目<a href="#Leetcode-167">Leetcode-167</a>，由于给定的数组是有序的，所以可以用二分查找解决。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-comment">// 利用有序特征</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp; nums, <span class="hljs-keyword">int</span> lt, <span class="hljs-keyword">int</span> gt, <span class="hljs-keyword">int</span> t)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(lt &lt;= gt)&#123;<br>            <span class="hljs-keyword">int</span> mid = lt + (gt - lt) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; t)&#123;<br>                lt = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; t)&#123;<br>                gt = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i)&#123;<br>            <span class="hljs-comment">// 查找numbers[j] == target - numbers[i]</span><br>            <span class="hljs-keyword">int</span> j = <span class="hljs-built_in">binarySearch</span>(numbers, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, target - numbers[i]);<br>            <span class="hljs-keyword">if</span>(j != <span class="hljs-number">-1</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>                res.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="关于二分查找其他模板">关于二分查找其他模板</h2><p>给定有序数组nums[N], 大小为n，数组下标从1开始，数组元素按照非降序排序。数组中有重复元素。</p><h3 id="查找元素为x的下标">查找元素为x的下标</h3><p>多解的情况返回一个即可。查找不到返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] == x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)&#123;<br>            l = mid - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找大于等于x的第一个元素的下标">查找大于等于x的第一个元素的下标</h3><p>条件同上，不存在返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] &gt;= x)&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[l] == x ? l : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找大于x的第一个元素的下标">查找大于x的第一个元素的下标</h3><p>条件同上，不存在返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">int</span> l </span>= <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] &gt; x)&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[l] &gt; x ? l : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="哈希表">哈希表</h1><p>C++的STL中的<em>unordered_map</em>底层实现是哈希表。（<del>当然自己手搓一个也可以</del>）</p><h2 id="题目1-1">题目1</h2><p><a href="https://leetcode.com/problems/two-sum/">Leetcode-1. Two Sum</a>。</p><p>将nums放入<strong>unordered_map</strong>中，对每一个元素nums[i]，查找target-nums[i]是否存在。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; m;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++ i)&#123;<br>            m[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++ i)&#123;<br>            <span class="hljs-keyword">int</span> t = target - nums[i];<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(t) &amp;&amp; m[t] != i)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(m[t]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目2-1">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/4sum-ii/">Leetcode-454. 4Sum II</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p>样例：</p><p><strong>Input:</strong> A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]</p><p><strong>Output:</strong> <code>2</code></p><p><strong>Explanation:</strong> The two tuples are:</p><ol type="1"><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p>题目大意：给定四个整型数组A、B、C和D，寻找使得A[i]+B[j]+C[k]+D[l]==0的组合数。</p><h3 id="暴力解法-4">暴力解法</h3><p>  四重循环，时间复杂度为O(n^4)，提交必然超时。</p><h3 id="mapunordered_map">map/unordered_map</h3><p>  考虑将D放入查找表中，时间复杂度降为<span class="math inline">\(O(n^3)\)</span></p><p>  将C+D放入查找表，时间复杂度降为<span class="math inline">\(O(n^2)\)</span></p><p>  注意：B+C+D都放？那就是<span class="math inline">\(O(n^3)\)</span>了</p><p>  这里实际上是对查找表的键值对进行优化。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; C, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; D)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mpt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c: C)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d : D)<br>                ++ mpt[c + d];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a: A)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b: B)<br>                <span class="hljs-keyword">if</span>(mpt.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-a-b)!=mpt.<span class="hljs-built_in">end</span>())<br>                    res += mpt[<span class="hljs-number">0</span> - a - b];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3-1">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/">Leetcode-350.Intersection of Two Arrays II</a></p><p>题目难度：Easy</p><p>题目描述：Given two arrays, write a function to compute their intersection.</p><p>样例1:</p><p><strong>Input:</strong> nums1 = <code>[1,2,2,1]</code>, nums2 = <code>[2,2]</code></p><p><strong>Output:</strong> <code>[2,2]</code></p><p>样例2:</p><p><strong>Input:</strong> nums1 = <code>[4,9,5]</code>, nums2 = <code>[9,4,9,8,4]</code></p><p><strong>Output:</strong> <code>[4,9]</code></p><p><strong>Note</strong>:</p><ul><li>Each element in the result should appear as many times as it shows in both arrays.</li><li>The result can be in any order.</li></ul><p>题目大意：返回nums1和nums2的交集，值相同的元素也分开统计。</p><p>  本题与「<a href="https://leetcode.com/problems/intersection-of-two-arrays/submissions/">Leetcode-349.Intersection of Two Arrays</a>」很类似，但是这里需要统计重复的元素。</p><h3 id="代码-3">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-comment">// unordered_map底层实现为哈希表，插入查找时间复杂度为O(1)</span><br><span class="hljs-comment">// map底层实现为平衡二叉树，插入查找时间复杂度为O(logn)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mp;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : nums1)<br>            ++ mp[n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : nums2)<br>            <span class="hljs-keyword">if</span>(mp[n]-- &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 先判断后自减</span><br>                vt.<span class="hljs-built_in">push_back</span>(n);<br>        <span class="hljs-keyword">return</span> vt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>  注意：map中只要访问了一次某元素，无论该元素之前是否存在，访问之后会自动插入到该map中，在C++中初始值为0。</p><h3 id="相关训练-3">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/group-anagrams/">Leetcode-49.Group Anagrams</a></td><td><a href="#Leetcode-49">Solution</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong>；<strong>Uber</strong>；<strong>Bloomberg</strong>；<strong>Yelp</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/3sum/">Leetcode-15. 3Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/015-3sum/3sum.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong>；<strong>Microsoft</strong>；<strong>Bloomberg</strong>；<strong>Adobe</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/4sum/">Leetcode-18. 4Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/018-4sum/4sum.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/3sum-closest/">Leetcode-16. 3Sum Closest</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/016-3sum-closest/3sum-closest.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/valid-anagram/">Leetcode-242.Valid Anagram</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/242-valid-anagram/valid-anagram.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Amazon</strong>；<strong>Uber</strong>；<strong>Yelp</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/word-pattern/">Leetcode-290.Word Pattern</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/290-word-pattern/word-pattern.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Dropbox</strong>；<strong>Uber</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/isomorphic-strings/">Leetcode-205.Isomorphic Strings</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/205-isomorphic-strings/isomorphic-strings.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Linkedin</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/sort-characters-by-frequency/">Leetcode-451.Sort Characters By Frequency</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/451-sort-characters-by-frequency/sort-characters-by-frequency.cpp">Solution-C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong>；<strong>Amazon</strong></td></tr></tbody></table><div id="Leetcode-49"></div><p>Leetcode-49 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//加速cin,cout</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> _ = [] &#123;<br>    std::ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;();<br><br><span class="hljs-comment">// time: O(nlogs) s为最大字符串长度</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; mpt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;str: strs)&#123;<br>            string s = str;<br>            <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span>(!mpt.<span class="hljs-built_in">count</span>(s))&#123;<br>                mpt[s] = res.<span class="hljs-built_in">size</span>();<br>                vector&lt;string&gt; r;<br>                res.<span class="hljs-built_in">push_back</span>(r);<br>            &#125;<br>            res[mpt[s]].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3-2">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/number-of-boomerangs/">Leetcode-447. Number of Boomerangs</a></p><p><strong>Google</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given <em>n</em> points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p><p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong> (inclusive).</p><p>样例：</p><p><strong>Input:</strong> <code>[[0,0],[1,0],[2,0]]</code></p><p><strong>Output:</strong> <code>2</code></p><p><strong>Explanation:</strong> The two boomerangs are <strong>[[1,0],[0,0],[2,0]]</strong> and <strong>[[1,0],[2,0],[0,0]]</strong></p><p>题目大意：给出平面上n个点，寻找使得i,j两点距离等于i,k两点距离的三元组(i,j,k)的个数。n最大值为<strong>500</strong>，点坐标范围为<strong>[-10000, 10000]</strong>。</p><h3 id="暴力解法-5">暴力解法</h3><p>  三重循环。时间复杂度为O(n^3)。</p><h3 id="unordered_map">unordered_map</h3><p>  双重遍历points，计算points[i] 与points[j]之间的距离放入查找表中。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 这里计算“距离“，不进行开方（避免出现浮点数）</span><br>    <span class="hljs-comment">// 计算distance可能会超出int范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp;pa, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp;pb)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (pa.first - pb.first) * (pa.first - pb.first) + (pa.second - pb.second) * (pa.second - pb.second);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mpt;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; points.<span class="hljs-built_in">size</span>(); ++j)<br>                <span class="hljs-keyword">if</span>(j != i)<br>                    ++ mpt[<span class="hljs-built_in">dis</span>(points[i],points[j])];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mpt.<span class="hljs-built_in">begin</span>(); it != mpt.<span class="hljs-built_in">end</span>(); ++it)&#123;<br>                <span class="hljs-keyword">if</span>(it-&gt;second &gt;= <span class="hljs-number">2</span>)<br>                    <span class="hljs-comment">// 选择计数</span><br>                    res += (it-&gt;second) * (it-&gt;second - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-4">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/max-points-on-a-line/">Leetcode-149.Max Points on a Line</a></td><td></td><td><strong>Hard</strong></td><td><strong>Linkedin</strong>；<strong>Twitter</strong>；<strong>Apple</strong></td></tr></tbody></table><h2 id="题目4-1">题目4</h2><p>题目来源：<a href="https://leetcode.com/problems/intersection-of-two-arrays/">Leetcode-349.Intersection of Two Arrays</a></p><p><strong>TWO SIGMA</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given two arrays, write a function to compute their intersection.</p><p>样例1:</p><p><strong>Input:</strong> nums1 = <code>[1,2,2,1]</code>, nums2 = <code>[2,2]</code></p><p><strong>Output:</strong> <code>[2]</code></p><p>样例2:</p><p><strong>Input:</strong> nums1 = <code>[4,9,5]</code>, nums2 = <code>[9,4,9,8,4]</code></p><p><strong>Output:</strong> <code>[9,4]</code></p><p>题目大意：给定两个数组，求它们的公共元素。注：结果中的公共元素只能出现一次。</p><h3 id="二分搜索">二分搜索</h3><p>一个简单的想法：先排序，然后遍历nums1，并在nums2中二分查找。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySerach</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; num, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, <span class="hljs-keyword">int</span> t)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(lo &lt;= hi)&#123;<br>            <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(t == num[mid]) <span class="hljs-keyword">return</span> mid;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; num[mid])&#123;<br>                lo = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> hi = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vt;<br>        <span class="hljs-keyword">if</span>(nums1.<span class="hljs-built_in">empty</span>() || nums2.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> vt;<br>        <span class="hljs-built_in">sort</span>(nums1.<span class="hljs-built_in">begin</span>(),nums1.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(nums2.<span class="hljs-built_in">begin</span>(),nums2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">int</span> n = nums1.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i &lt;= n - <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">binarySerach</span>(nums2,<span class="hljs-number">0</span>,nums2.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,nums1[i]) != <span class="hljs-number">-1</span>)&#123;<br>                vt.<span class="hljs-built_in">push_back</span>(nums1[i]);<br>            &#125;<br>            <span class="hljs-keyword">while</span>(i + <span class="hljs-number">1</span> &lt;= n - <span class="hljs-number">1</span> &amp;&amp; nums1[i + <span class="hljs-number">1</span>] == nums1[i]) ++i;<br>            ++ i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="使用stl容器set">使用STL容器：set</h3><p>  set是STL中的容器，具有去重、排序的功能。我们先将nums1放入set中，再遍历nums2， 在set中查找，若存在则为公共元素。unordered_set底层也是哈希表。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-comment">// set底层实现为平衡二叉树 插入查找操作时间复杂度为O(logn)</span><br><span class="hljs-comment">// 若使用unordered_set，插入查找操作时间复杂度为O(1) 可以作为优化</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vt;<br>        set&lt;<span class="hljs-keyword">int</span>&gt; record;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : nums1)<br>            record.<span class="hljs-built_in">insert</span>(n);<br>        <span class="hljs-comment">// 也可写成这样</span><br>        <span class="hljs-comment">// set&lt;int&gt; record(nums1.begin(), nums2.end());</span><br><br>        set&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> n : nums2)<br>            <span class="hljs-comment">// n存在record中</span><br>            <span class="hljs-keyword">if</span>(record.<span class="hljs-built_in">find</span>(n) != record.<span class="hljs-built_in">end</span>()) <br>                res.<span class="hljs-built_in">insert</span>(n);<br>        <span class="hljs-comment">// 使用&lt;set&gt;res去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = res.<span class="hljs-built_in">begin</span>(); it != res.<span class="hljs-built_in">end</span>(); ++it)<br>            vt.<span class="hljs-built_in">push_back</span>(*it);<br>        <span class="hljs-keyword">return</span> vt;<br>        <span class="hljs-comment">// 也可写成这样</span><br>        <span class="hljs-comment">// return vector&lt;int&gt;(res.begin(), res.end());</span><br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-5">相关训练：</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/happy-number/">Leetcode-202.Happy Number</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/202-happy-number/happy-number.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Uber</strong>；<strong>Airbnb</strong>；<strong>Twitter</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>滑动窗口</tag>
      
      <tag>查找</tag>
      
      <tag>二分</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表技巧</title>
    <link href="/2022/03/09/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/03/09/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的简单链表题，简单，但是可以有一些常用的小技巧。</p><h1 id="创建虚拟头结点">创建虚拟头结点</h1><p>  LeetCode通常会给出单链表，头节点也会存信息，常常需要对头节点特判，增加了冗余代码。</p><p>  这时候可以考虑增加一个虚拟头节点，指向题目给的单链表，然后就不需要特判了。</p><h2 id="题目1">题目1</h2><p>题目来源：<a href="https://leetcode.com/problems/remove-linked-list-elements/">Leetcode-203.Remove Linked List Elements</a></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p><p>样例：</p><p><strong>Input:</strong> <code>1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6</code>, <strong><em>val</em></strong> = <code>6</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>题目大意：给定一个链表，删除值为val的结点。</p><h3 id="解析">解析</h3><p>  删除的结点可能是头结点，所以要设立一个虚拟的头结点，然后使用三个指针来遍历链表即可。删除链表结点：前驱结点的next指向后继结点。</p><p>  很明显，因为头结点也会被操作，所以此类问题最好设置虚拟的头结点，使得原来的头结点和其他结点一样，都有前驱，不必为头结点特别操作。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-comment">// 链表结点定义省略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        ListNode* vihead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        vihead-&gt;next = head;<br>        ListNode *pre = vihead, *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val == val)&#123;<br>                pre-&gt;next = cur-&gt;next;<br>                cur = pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                pre = cur;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vihead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目2">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode-24.Swap Nodes in Pairs</a></p><p><strong>Microsoft</strong>；<strong>Bloomberg</strong>；<strong>Uber</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list's nodes, only nodes itself may be changed.</p><p>样例：</p><p>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p><h3 id="解析-1">解析</h3><p>  类似地，本题也需要创建虚拟头结点。所谓交换结点不过也是一种对链表的基本操作。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode *nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        ListNode *p = nhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next&amp;&amp;p-&gt;next-&gt;next)&#123;<br>            ListNode *n1 = p-&gt;next, *n2 = n1-&gt;next;<br>            ListNode *next = n2-&gt;next;<br>            n2-&gt;next = n1;<br>            n1-&gt;next = next;<br>            p-&gt;next = n2;<br>            p = n1;<br>        &#125;<br>        <span class="hljs-comment">//return nhead-&gt;next;</span><br>        <span class="hljs-comment">// 删除虚拟头结点</span><br>        <span class="hljs-keyword">auto</span> res = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;        <br>        <span class="hljs-comment">// 返回真实头结点</span><br>        <span class="hljs-keyword">return</span> res;    <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><p>  其实所有的链表题都可以加个虚拟头节点（<del>这个甚至都不能算是技巧了</del>）。</p><h3 id="相关训练">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode-82.Remove Duplicates from Sorted List II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/082-remove-duplicates-from-sorted-list-ii/remove-duplicates-from-sorted-list-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode-21.Merge Two Sorted Lists</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/021-merge-two-sorted-lists/merge-two-sorted-lists.cpp">C++</a> <a href="https://github.com/yangyangu/MyLeetCode/blob/master/021-merge-two-sorted-lists/merge-two-sorted-lists.java">Java</a></td><td><strong>Easy</strong></td><td><strong>Amazon</strong>；<strong>Linkedin</strong>；<strong>Microsfot</strong>；<strong>Apple</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode-25.Reverse Nodes in k-Group</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/025-reverse-nodes-in-k-group/reverse-nodes-in-k-group.cpp">C++</a></td><td><strong>Hard</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">Leetcode-237.Delete Node in a Linked List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/237-delete-node-in-a-linked-list/delete-node-in-a-linked-list.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Microsoft</strong>；<strong>Adobe</strong>；<strong>Apple</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/insertion-sort-list/">Leetcode-147.Insertion Sort List</a></td><td><a href="#List-Sort">链表排序</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/sort-list/">Leetcode-148.Sort List</a></td><td><a href="#List-Sort">链表排序</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="链表双指针">链表双指针</h1><p>  双指针无论是在数组还是在链表中都是很常用的技巧。</p><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Leetcode-19.Remove Nth Node From End of List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p>样例：</p><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.</p><p>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p>题目大意：给定一个链表，删除倒数第n个结点。</p><p>Note：题目保证n是合法的。注意《剑指offer》中也有此题，但是不保证n的合法性，所以要自行处理。</p><h3 id="两次遍历">两次遍历</h3><p>第一次遍历获取链表长度；第二次遍历删除倒数第n个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *pre = head, *cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> head-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next) &#123;<br>            cur = cur-&gt;next;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 删除p的后继</span><br>        <span class="hljs-keyword">auto</span> next = p-&gt;next;<br>        pre-&gt;next = pre-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> next;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="使用双指针一次遍历">使用双指针：一次遍历</h3><p>使用两个指针p和q， p指向头结点，同时p和q在链表中的距离为n，那么同时将p和q向后移动直到q到达尾结点，此时p恰好为倒数第n + 1个结点。删除p的后继结点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// momory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 使用虚拟头结点</span><br>        ListNode *nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        ListNode *p = nhead, *q = nhead;<br>        <span class="hljs-comment">// 使得p和q相距为n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; ++i)<br>            q = q-&gt;next;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 删除p的后继</span><br>        <span class="hljs-keyword">auto</span> next = p-&gt;next;<br>        p-&gt;next = p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> next;<br><br>        <span class="hljs-comment">// 删除虚拟头结点并返回头指针</span><br>        <span class="hljs-keyword">auto</span> res = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-1">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/rotate-list/">Leetcode-61.Rotate List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/061-rotate-list/rotate-list.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/reorder-list/">Leetcode-143.Reorder List</a></td><td></td><td><strong>Medium</strong></td><td></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/palindrome-linked-list/">Leetcode-234.Palindrome Linked List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/234-palindrome-linked-list/palindrome-linked-list.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong></td></tr></tbody></table><div id="List-Sort"></div><h1 id="链表排序">链表排序</h1><p>  把链表存到数组排序的解法不算数！</p><h2 id="插入排序insertion-sort">插入排序(Insertion Sort)</h2><p>题目来源：<a href="https://leetcode.com/problems/insertion-sort-list/">Leetcode-147.Insertion Sort List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Sort a linked list using insertion sort.</p><p>样例1：</p><p><strong>Input:</strong> <code>4-&gt;2-&gt;1-&gt;3</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4</code></p><p>样例1：</p><p><strong>Input:</strong> <code>-1-&gt;5-&gt;3-&gt;4-&gt;0</code></p><p><strong>Output:</strong> <code>-1-&gt;0-&gt;3-&gt;4-&gt;5</code></p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        <span class="hljs-keyword">auto</span> cur = head-&gt;next, prev = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &gt; prev-&gt;val)&#123;<br>                <span class="hljs-comment">// 当前元素与前驱元素相对有序</span><br>                prev = cur;<br>                cur = cur-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 当前元素与前驱元素无序</span><br>                <span class="hljs-keyword">auto</span> ptr_pre = nhead, ptr = nhead-&gt;next;<br>                <span class="hljs-comment">// 在头结点-前驱元素区间找到插入点</span><br>                <span class="hljs-keyword">while</span>(ptr != cur &amp;&amp; cur-&gt;val &gt; ptr-&gt;val)&#123;<br>                    ptr_pre = ptr;<br>                    ptr = ptr-&gt;next;<br>                &#125;<br>                <span class="hljs-comment">// 插入元素并维护cur指针</span><br>                <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>                ptr_pre-&gt;next = cur;<br>                cur-&gt;next = ptr;<br>                prev-&gt;next = next;<br>                cur = next;<br>            &#125;<br>        &#125;<br>        head = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;        <span class="hljs-comment">// 删除虚拟头结点</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h2 id="归并排序merge-sort">归并排序(Merge Sort)</h2><p>题目来源：<a href="https://leetcode.com/problems/sort-list/">Leetcode-148.Sort List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p>样例1：</p><p><strong>Input:</strong> <code>4-&gt;2-&gt;1-&gt;3</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4</code></p><p>样例2：</p><p><strong>Input:</strong> <code>-1-&gt;5-&gt;3-&gt;4-&gt;0</code></p><p><strong>Output:</strong> <code>-1-&gt;0-&gt;3-&gt;4-&gt;5</code></p><h3 id="自底向上">自底向上</h3><p>  <strong>自底向上(Bottom-Up)</strong>的思路与自顶向下的思路相反。自顶向下是将表不断二分，直到每个子表剩下一个元素，然后再向上归并。二自底向上则是从单个元素不断归并，从一到二， 从二到四。直到恢复成一个有序表。</p><p>  以下AC代码使用了栈作为辅助空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-comment">// 由于使用辅助空间，所以空间复杂度为O(n)。注：数组的归并排序也使用辅助空间。</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 归并两个有序的链表并返回</span><br>    <span class="hljs-comment">// 定义只有一个结点或没有结点的链表是有序的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode *h1, ListNode * h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(! h1 &amp;&amp; !h2) <span class="hljs-keyword">return</span> h1;<br>        <span class="hljs-keyword">if</span>(! h1) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span>(! h2) <span class="hljs-keyword">return</span> h1;<br>        <span class="hljs-keyword">auto</span> nhead = h1-&gt;val &lt; h2-&gt;val ? h1 : h2;<br>        <span class="hljs-keyword">if</span>(nhead == h1) h1 = h1-&gt;next;<br>        <span class="hljs-keyword">else</span> h2 = h2-&gt;next;<br>        <span class="hljs-keyword">auto</span> cur = nhead;<br>        <span class="hljs-keyword">while</span>(h1 &amp;&amp; h2)&#123;<br>            <span class="hljs-keyword">if</span>(h1-&gt;val &lt; h2-&gt;val)&#123;<br>                cur-&gt;next = h1;<br>                h1 = h1-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = h2;<br>                h2 = h2-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h1) cur-&gt;next = h1;<br>        <span class="hljs-keyword">else</span> cur-&gt;next = h2;<br>        <span class="hljs-keyword">return</span> nhead;<br>    &#125;<br>    <span class="hljs-comment">// 对链表进行自底向上的归并排序</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        stack&lt;ListNode*&gt; stk, hstk;<br>        <span class="hljs-comment">// 将所有结点装入辅助栈</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-keyword">auto</span> next = head-&gt;next;<br>            head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            stk.<span class="hljs-built_in">push</span>(head);<br>            head = next;<br>        &#125;<br>        <span class="hljs-comment">// 当栈内链表数大于2 还可以归并</span><br>        <span class="hljs-comment">// 否则归并完成</span><br>        <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-comment">// 实现两两归并</span><br>                <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>                    hstk.<span class="hljs-built_in">push</span>(stk.<span class="hljs-built_in">top</span>());<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">auto</span> h1 = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">auto</span> h2 = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">merge</span>(h1, h2);<br>                    hstk.<span class="hljs-built_in">push</span>(h);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!hstk.<span class="hljs-built_in">empty</span>())&#123;<br>                stk.<span class="hljs-built_in">push</span>(hstk.<span class="hljs-built_in">top</span>());<br>                hstk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="自顶向下">自顶向下</h3><p>  使用「自顶向下」的思路和归并排序的数组实现方式非常类似，我们需要找到链表的中间结点。这里用了一个trick，用两个指针：slow和fast，slow每次指向后继，而fast指向后继的后继，直到fast到达链表尾处，slow的后继就是中间结点。然后就容易实现对链表的归并排序</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(logn) 递归的深度是logn</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 归并两个有序的链表并返回</span><br>    <span class="hljs-comment">// 定义只有一个结点或没有结点的链表是有序的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode *h1, ListNode * h2)</span></span>&#123;<br>        <span class="hljs-comment">//... 同上</span><br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode *slow = head, * fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        fast = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(fast));<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="链表反转">链表反转</h1><h2 id="题目-1">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode-206.Reverse Linked List</a></p><p><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Amazon</strong>；<strong>Apple</strong>；<strong>Uber</strong>；<strong>Bloomberg</strong>；</p><p><strong>Twitter</strong>；<strong>Yahoo</strong>；<strong>Zenefits</strong>；<strong>Snapchat</strong>；<strong>Adobe</strong>；<strong>Yelp</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Reverse a singly linked list.</p><p>样例：</p><p><strong>Input:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code></p><p><strong>Output:</strong> <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></p><p>题目大意：给定一个链表，改变链表结点原有指向使其反转，返回反转后的链表头指针。</p><h3 id="解法1">解法1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br> *     <span class="hljs-keyword">int</span> val;<br> *     ListNode *next;<br> *     <span class="hljs-built_in">ListNode</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br> * &#125;;<br> */<br><br><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用三个指针 当前cur、下一结点next、前驱结点prev</span><br>        ListNode * cur = pHead, * next = <span class="hljs-literal">nullptr</span>, * prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> cur;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        cur-&gt;next = prev;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="解法2">解法2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode *cur = head, *pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-comment">// next的存在依赖于cur是否非空</span><br>            ListNode *next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-2">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Leetcode-92.Reverse Linked List II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/092-reverse-linked-list-ii/reverse-linked-list-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="哈希表">哈希表</h1><p>  之前面试腾讯的时候，面试官出过LRU的题，一开始我的解法很朴素：用双链表解决，但是显然这样查找的复杂度为<span class="math inline">\(O(n)\)</span>。怎么优化呢？面试官提示道：如果要<span class="math inline">\(O(1)\)</span>查找，那答案只有一个了吧？我瞬间惊呼：用哈希表。</p><h2 id="题目-2">题目</h2><p>  注意：现在这题如果不用哈希表优化，可能会TLE。</p><p>题目来源：<a href="https://leetcode.com/problems/lru-cache/">Leetcode-146.LRU缓存机制</a></p><p><strong>ByteDance</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br /><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p>样例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">LRUCache cache = new LRUCache( 2 /* capacity */ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br></code></pre></div></td></tr></table></figure><h3 id="代码-3">代码</h3><p>  这个代码有点瑕疵，用了好多特判。后续会改一下。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    Node * next, * prev;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _k, <span class="hljs-keyword">int</span> _v): <span class="hljs-built_in">key</span>(_k), <span class="hljs-built_in">value</span>(_v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">int</span> size;<br>    Node * head, * tail;<br>    map&lt;<span class="hljs-keyword">int</span>, Node *&gt; mpt;<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>-&gt;tail = <span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> node = mpt[key];<br>        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> node-&gt;value;<br>            <span class="hljs-keyword">if</span>(tail == node) tail = tail-&gt;prev;<br>            <span class="hljs-keyword">auto</span> prev = node-&gt;prev, next = node-&gt;next;<br>            <span class="hljs-keyword">if</span>(next) next-&gt;prev = prev;<br>            prev-&gt;next = next;<br><br>            node-&gt;next = head-&gt;next;<br>            head-&gt;next-&gt;prev = node;<br>            node-&gt;prev = head;<br>            head-&gt;next = node;<br>            <span class="hljs-keyword">return</span> node-&gt;value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">auto</span> node = mpt[key];<br>            node-&gt;value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size &gt;= capacity)&#123;<br>            <span class="hljs-keyword">auto</span> last = tail;<br>            tail = tail-&gt;prev;<br>            tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            last-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>            <br>            -- size;<br>            mpt[last-&gt;key] = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>(last);<br>        &#125;<br>        Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>        <span class="hljs-keyword">if</span>(tail == head)&#123;<br>            head-&gt;next = node;<br>            node-&gt;prev = head;<br>            tail = head-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node-&gt;next = head-&gt;next;<br>            head-&gt;next-&gt;prev = node;<br>            head-&gt;next = node;<br>            node-&gt;prev = head;<br>        &#125;<br>        ++ size;<br>        mpt[key] = node;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></div></td></tr></table></figure><h1 id="检测环">检测环</h1><p>  核心思想：用fast和slow两个指针，fast每次跑两步，slow每次跑一步。如果链表存在环，则最终fast会与slow相遇。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode * root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(! root || ! root-&gt;next)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> slow = root, fast = root, prev = root;<br>    <span class="hljs-keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>            prev = root;<br>            <span class="hljs-keyword">while</span>(prev != slow)&#123;<br>                prev = prev-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="其他">其他</h1><p>  有时候可能需要自己在本地IDE里写题，下面给出一些在IDE的操作技巧（基于C++）。</p><h2 id="链表结构体">链表结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode * next;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>: val(x), next(nullptr)&#123;</span>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="创建单链表">创建单链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), cur = root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it: arr)&#123;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(it);<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="打印链表">打印链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(ListNode *root)</span></span>&#123;<br>    ListNode * cur = root;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        cout &lt;&lt; cur-&gt;val;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next)<br>            cout &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>双指针</tag>
      
      <tag>链表</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的博客记录</title>
    <link href="/2022/03/09/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/09/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<em>就在刚才，我删掉了之前写的博客。</em><p align="right">——作者</p><p>  2018年初至今，我写了大约52篇文章，大部分都是关于LeetCode题解的。有一些类型的题目我刷了很多，每一题都单独成篇，可惜自己觉得写出来的东西确实没有什么干货，干脆直接删除了。BTW，这是我的<a href="https://leetcode-cn.com/u/yangyangu/">LeetCode</a>。除了题解，我还写了一些大数据、深度学习的文章，但也都是废话。</p><p>  大约在2017年，我开始断断续续学习编程。不可否认的是，教计算思维的大学老师讲得很好，带我入了C语言的门，但是可惜，我写代码还是很艰辛。后来有一个直系学长推荐了LeetCode等众多OJ，以及我自己在很多在线学习的网站学了很长一段时间的算法、数据结构和C++（这些课程的老师好好反思自己的念PPT课堂），这里要特别感谢<a href="https://github.com/liuyubobobo">liuyubobobo</a>老师。当然，这些都是后话了。</p><p>  然后，终于可以顺利地用编程语言描述自己的想法了，写LeetCode自然是越写越顺心，哪怕是碰到Medium以上的题目，也是可以慢慢摸索出来的（<del>实在不行还有题解</del>）。</p><p>  不过，再往后，LeetCode上的题目也越来越不像是面试题了，更像是算法竞赛的水题/中等题。时至今日，甚至出现了让OI退役选手都惊讶的算法题。我理解，随着求职市场内卷化程度剧增，这种情况是不可避免的。</p><p>  当年的博客里，我主要完成以下类型的题目：</p><ul><li>回溯</li><li>双指针</li><li>搜索</li><li>二叉树</li><li>链表</li><li>动态规划</li><li>贪心</li><li>队列</li><li>数学</li><li>排序</li><li>二分</li><li>图</li></ul><p>  当然，这些类型的题，如果能熟练掌握（Bug-free、最优解法、默写），无论是找工作面试还是其他算法考试，都足以应对了。哈哈，我确实还不太能做到<em>熟练掌握</em>。我承认之前写的博客都是在水文字，把题目大意、思路和代码放上去，质量真的不高。讲真，就连我自己也很少去翻之前写的东西。</p><p>  有一说一，之前写的文章，放在简历里还是可以的。虽然没法唬住面试官，但是至少能增加一点对面试者的好感，至少ta会严谨的对待自己的学习，哪怕学的东西很基础。这或许是我写博客的初衷——把博客做成一个长期的简历。</p><p>  未来我的想法是：把文章精简化。譬如说，在刷题的文章里，我希望能过通过一道题来解决一类题，学会这道题背后的算法思想，而不只是Accepted这一道题。在其他类型的文章里，也应该能做到类似的事情。</p><p>  因此，我会把之前删掉的文章整合成质量更高的合集（<del>哈哈不是删除了嘛</del>）。希望能让自己更深入的理解其中的思想。</p><p>  最近刷题的主战场在<a href="https://www.acwing.com/">AcWing</a>，一句话：y总YYDS！目前，我希望学好以下类型的题目：</p><ul><li>基础数据结构模板</li><li>树状数组、线段树、Trie、UnionFind、AC自动机...</li><li>各种类型的DP</li><li>搜索优化</li><li>前缀、差分、位运算</li><li>...</li></ul><p>  大家加油！</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>献给自己</title>
    <link href="/2022/03/09/%E7%8C%AE%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
    <url>/2022/03/09/%E7%8C%AE%E7%BB%99%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p><em>  很长一段时间，我的生活看似马上就要开始了，真正的生活，但是总是有一些阻碍阻拦着，有些事得先解决，有些工作待完成，时间貌似够用，还有一笔债务要去付清，然后生活就会开始。</em></p><p><em>  最后我终于明白，这些障碍，正是我的生活。</em></p><p align="right">——艾弗里德·德索萨</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
