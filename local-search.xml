<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>机器学习之SVM</title>
    <link href="/2022/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM/"/>
    <url>/2022/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8BSVM/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p><span class="math inline">\(Support{\,}Vector{\,}Machine\)</span>（SVM,支持向量机）是机器学习中的算法，通常用于分类问题。</p><h1 id="线性模型">线性模型</h1><p>假定在一个平面内，能够用一条直线将正负样本分开，那么就称为线性可分（<span class="math inline">\(Liner{\,} Sepratable\)</span>）。否则就是线性不可分。</p><h1 id="问题">问题</h1><p>显然有很多直线可以区分，那么如何衡量哪条直线更好？</p><h1 id="性能指标">性能指标</h1><p>1、将直线平移到一类样本的最近，得到L1</p><p>2、重复这一个过程移动到另一类样本最近，得到L2</p><p>3、计算<span class="math inline">\(d=L1\)</span>到<span class="math inline">\(L2\)</span>的距离</p><p>那么d即优化的目标，寻找L1和L2，使得d最大。</p><p><span class="math inline">\(d\)</span>: 间隔（<span class="math inline">\(Margin\)</span>）</p><p>将平行线碰到的向量称为支持向量（<span class="math inline">\(Support{\,}Vector\)</span>）</p><p>实际上，<span class="math inline">\(L\)</span>只与少数支持向量有关，故可以用在小样本上。</p><h1 id="数学描述">数学描述</h1><p>【参考： 《支持向量机导论》】</p><h2 id="定义">定义</h2><p>1、训练数据、标签</p><p><span class="math inline">\((x_i, y_i), i = 1 \cdots N\)</span></p><p><span class="math inline">\(x_i\)</span>为向量， <span class="math inline">\(y_i\)</span>为标签(+1 or -1)。注：这里是一个二分类问题。</p><p>2、线形模型：找到一个超平面<span class="math inline">\((\omega，b)\)</span>，满足<span class="math inline">\(\omega^TX + b = 0\)</span></p><p><span class="math inline">\(\omega\)</span>也是一个向量，维度与<span class="math inline">\(x_i\)</span>相等</p><p>3、一个训练集线性可分是指：</p><p>对于训练集{(<span class="math inline">\(x_i, y_i\)</span>)}, <span class="math inline">\(i=1\cdots N\)</span>,</p><p><span class="math inline">\(\exists (\omega, b)\)</span>，使得对<span class="math inline">\(\forall i=1\cdots N\)</span>，有:</p><p><span class="math inline">\(\left\{\begin{aligned} \omega^Tx_i + b \geq 0,y_i = + 1\\ \omega^Tx_i + b \leq 0,y_i = -1 \end{aligned}\right.\)</span></p><p>即：<span class="math inline">\(y_i[\omega^Tx_i + b] \geq 0\)</span></p><p>其他：用凸包定义。</p><h2 id="机器学习步骤">机器学习步骤</h2><h3 id="step1">Step1</h3><p>限定模型。用一个方程。</p><h3 id="step2">Step2</h3><p>模型留出待定参数。此处为W和b</p><h3 id="step3">Step3</h3><p>用训练数据确定W和b的值。训练完成。</p><h2 id="优化问题凸优化问题二次优化问题">优化问题（凸优化问题/二次优化问题）</h2><p>最小化(Minimize): <span class="math inline">\(\frac{1}{2} ||\omega||^2\)</span></p><p>限制条件(Subject to): <span class="math inline">\(y_i[\omega^Tx_i + b] \geq 1, i=1\cdots N\)</span></p><h2 id="注意到如下两个事实">注意到如下两个事实：</h2><h3 id="事实1">事实1:</h3><p><span class="math inline">\(\omega^Tx + b = 0\)</span>与<span class="math inline">\(a\omega^Tx + b = 0\)</span>是同一个平面。<span class="math inline">\(a\in R^+\)</span>。</p><p>若<span class="math inline">\((\omega, b)\)</span>满足公式一，则<span class="math inline">\((a\omega, ab)\)</span>也满足。</p><h3 id="事实2">事实2:</h3><p>点到平面距离公式。</p><p>平面<span class="math inline">\(\omega_1x + \omega_2y + b = 0\)</span>，则<span class="math inline">\((x_0, y_0)\)</span>到平面距离<span class="math inline">\(d=\frac{|\omega_1x_0 + \omega_2y_0 + b|}{\sqrt{\omega_1^2 | \omega_2^2}}\)</span></p><h2 id="推论">推论</h2><p>根据事实1，可以用<span class="math inline">\(a\)</span>去放缩<span class="math inline">\((w, b)\longrightarrow(a\omega, ab)\)</span>，最终使得在支持向量<span class="math inline">\(x_0\)</span>上有：</p><p><span class="math inline">\(|\omega^Tx_0 + b| = 1\)</span></p><p>（也就是说可以通过对<span class="math inline">\((\omega, b)\)</span>进行缩放，使得<span class="math inline">\(d\)</span>的分母为1）</p><p>此时支持向量与平面的距离<span class="math inline">\(d=\frac{1}{||\omega||}\)</span>（根据事实2）</p><p>故<span class="math inline">\(max(d) = minimize(||\omega||)\)</span></p><p>这里将最大化<span class="math inline">\(d\)</span>转化为最小化<span class="math inline">\(\omega\)</span>的模。</p><p>接下来是解决优化问题。</p><h1 id="二次规划quadratic-programming">二次规划(Quadratic Programming)</h1><p>1、目标函数(Object Function) 二次项</p><p>2、限制条件。一次项。</p><p>要么无解，要么只有一个极值，且为全局最优值。（目标函数为凸函数）</p><h1 id="非线性模型">非线性模型</h1><h2 id="svm如何处理非线性模型">SVM如何处理非线性模型？</h2><p>1、最小化 <span class="math inline">\(\frac{1}{2} ||\omega||^2 + c\sum_{i=1}^N\xi_i\)</span>（式1）</p><p>这里的<span class="math inline">\(c\)</span>也是事先设定的参数，<span class="math inline">\(c\sum_{i=1}^N\xi_i\)</span>为正则项(Regulation Term)</p><p>2、限制条件 <span class="math inline">\(\left\{\begin{matrix}y_i[\omega^Tx_i + b] \geq 1 - \xi_i (i=1\cdots N) \\ \xi_i \geq 0 \end{matrix}\right.\)</span></p><p>3、定义高维映射<span class="math inline">\(\varphi(x)\)</span></p><p>若<span class="math inline">\(x\)</span>为低维、不可分的数据，经过<span class="math inline">\(x \rightarrow \varphi(x)\)</span>， <span class="math inline">\(\varphi(x)\)</span>为高维数据，那么<span class="math inline">\(\varphi(x)\)</span>可分的概率更高。</p><p>根据<span class="math inline">\(x_i = \varphi(x)\)</span>，此时限制条件可以修改为<span class="math inline">\(y_i[\omega^T\varphi(x) + b] &gt;= 1 - \xi_i\)</span></p><h2 id="如何选出varphix">如何选出<span class="math inline">\(\varphi(x)\)</span>？</h2><p>首先，<span class="math inline">\(\varphi(x)\)</span>是无限维。那么此时<span class="math inline">\(\varphi(x)\)</span>线性可分的概率为1。</p><p>其次，我们可以不知道无限维<span class="math inline">\(\varphi(x)\)</span>的显式表达式，我们只需知道一个核函数(Kernel function):</p><p><span class="math inline">\(K(x_1, x_2) = \varphi(x_1)^T\varphi(x_2)\)</span></p><p>则式1的优化式仍然可解。</p><h2 id="核函数">核函数</h2><p>1、高斯核：<span class="math inline">\(K(x_1, x_2) = e^-\frac{||x_1 - x_2||^2}{2\sigma^2}\)</span> ，<span class="math inline">\(\varphi(x)\)</span>为无限维。</p><p>2、多项式核：<span class="math inline">\(K(x_1, x_2) = (x_1^Tx_2 + 1)^d， d\)</span>为 多项式阶数，<span class="math inline">\(\varphi(x)\)</span>为有限维。</p><p>如何在只知道<span class="math inline">\(K(x_1, x_2)\)</span>、不知道<span class="math inline">\(\varphi(x)\)</span>的情况下去替换？</p><h2 id="优化理论">优化理论</h2><h3 id="原问题prime-problem">原问题(Prime Problem)：</h3><p>这是一个非常general的定义。</p><p>最小化<span class="math inline">\(f(\omega)\)</span></p><p>限制条件: <span class="math inline">\(\left\{\begin{matrix}g_i(\omega) \leq 0, i=1\cdots K (K个不等式定义) \\ h_i(\omega) = 0，i=1\cdots M (M个不等式定义)\end{matrix}\right.\)</span></p><hr /><h3 id="对偶问题dual-problem">对偶问题(Dual Problem):</h3><p>1、定义：</p><p><span class="math inline">\(L(\omega, \alpha, \beta) = f(\omega) + \sum_{i=1}^K\alpha_ig_i(\omega)+\sum_{i=1}^M\beta_ih_i(\omega) \\=f(\omega) + \alpha^Tg(\omega) + \beta^Th(\omega)\)</span> (向量形式)</p><p>2、对偶问题定义：</p><p>最大化：<span class="math inline">\(\theta(\alpha, \beta) = inf\left\{\begin{matrix}L(\omega, \alpha,\beta)\end{matrix}\right\}\)</span></p><p><span class="math inline">\(inf\)</span>为求最小值，限制<span class="math inline">\(\alpha和\beta\)</span>，遍历所有<span class="math inline">\(\omega\)</span>，使得<span class="math inline">\(L\)</span>最小，取最小的<span class="math inline">\(L\)</span>时的<span class="math inline">\(\omega\)</span>。</p><p>限制条件： <span class="math inline">\(\alpha_i \geq 0(i=1\cdots K)\)</span> 或 <span class="math inline">\(\alpha \geq 0\)</span>（向量的每一个分量都大于或等于0）</p><p>定义：<span class="math inline">\(G=f(\omega^*) - \theta(\alpha^*, \beta^*) \geq 0\)</span>，<span class="math inline">\(G\)</span>为原问题与对偶问题的间距(Duality Gap)。 （对于某些问题，可以证明<span class="math inline">\(G=0\)</span>）</p><h3 id="强对偶定理">强对偶定理</h3><p>这里不加证明地给出强对偶定理。</p><p>若<span class="math inline">\(f(\omega)\)</span>为凸函数，且<span class="math inline">\(g(\omega)=A\omega+b, h(\omega) = c\omega + d\)</span>，则此优化问题的原问题与对偶问题的<span class="math inline">\(G=0\)</span>。</p><p>即：<span class="math inline">\(f(\omega^x) = \theta(\alpha^x, \beta^*)\)</span>（意味着上面的证明中有两处需要取等号）</p><p>对 <span class="math inline">\(\forall i = 1\cdots K\)</span>(KKT条件),</p><p><span class="math inline">\(\left\{\begin{matrix}\ 或者 \alpha^*_i = 0 \\ 或者 g_i^*(\omega^*) = 0\end{matrix}\right.\)</span></p><h3 id="引入svm非线性模型">引入SVM非线性模型</h3><h4 id="优化目标">优化目标</h4><p>最小化 <span class="math inline">\(\frac{1}{2}||\omega||^2 + c\sum_{i=1}^N\xi_i\)</span>（首先这是一个凸函数）</p><p>限制条件：<span class="math inline">\(\left\{\begin{matrix}\ y_i[\omega^T\varphi(x)+b] \geq 1 - \xi_i \\ \xi_i \geq 0\end{matrix}\right.\)</span></p><h4 id="标准形式">标准形式</h4><p><span class="math inline">\(minimize: \frac{1}{2}||\omega||^2 - c\sum_{i=1}^N\xi_i\)</span></p><p><span class="math inline">\(subject{\,}to :\left\{\begin{matrix}\ 1+\xi_i-y_i\omega^T\varphi(x_i) - y_ib \leq 0 \\ \xi_i \leq 0 (i=1\cdots N)\end{matrix}\right.\)</span></p><h4 id="对偶问题">对偶问题</h4><p><span class="math inline">\(maximum: \theta(\alpha, \beta) = inf\left\{\begin{matrix}\frac{1}{2}||\omega||^2-c\sum_{i=1}^N\xi_i + \sum_{i=1}^N\beta_i\xi_i + \sum_{i=1}^N\alpha_i[1+\xi_i-y_i\omega^T\varphi(x_i)-y_ib]\end{matrix}\right\}\)</span>,对所有的<span class="math inline">\((\omega_i, \xi_i, \beta_i)\)</span></p><h4 id="补充">补充</h4><p>1、<span class="math inline">\(\omega\)</span>为一个向量，<span class="math inline">\(\omega=(\omega_1, \omega_2, \cdots, \omega_m)^T, f(\omega)\)</span>为一个数</p><p><span class="math inline">\(\frac{\partial f}{\partial \omega} = (\frac{\partial f}{\partial \omega_1}, \frac{\partial f}{\partial \omega_2}, \cdots, \frac{\partial f}{\partial \omega_m})^T\)</span></p><p>2、若<span class="math inline">\(f(\omega)=\frac{1}{2}||\omega||^2\)</span>， 则<span class="math inline">\(\frac{\partial f}{\partial \omega} = \omega\)</span></p><p>3、若<span class="math inline">\(f(\omega)=\omega^Tx\)</span>, 则<span class="math inline">\(\frac{\partial f}{\partial \omega} = x\)</span></p><h4 id="求解">求解</h4><p><span class="math inline">\(\frac{\partial L}{\partial \omega} = 0 \Rightarrow \omega-\sum_{i=1}^N\alpha_iy_i\varphi(x_i) = 0(用补充1) \Rightarrow \omega = \sum_{i=1}^N\alpha_iy_i\varphi(x_i)\)</span></p><p><span class="math inline">\(\frac{\partial L}{\partial \xi_i} = 0 \Rightarrow -c+\beta_i + \alpha_i = 0 \Rightarrow \alpha_i + \beta_i = c\)</span></p><p><span class="math inline">\(\frac{\partial L}{\partial b} = 0 \Rightarrow -\sum_{i=1}^N\alpha_iy_i=0 \Rightarrow \sum_{i=1}^N\alpha_iy_i = 0\)</span></p><p>代入<span class="math inline">\(\theta(\alpha, \beta) = L(\omega_i,\xi_i,b)\)</span>中，</p><p>化简： <span class="math inline">\(\theta(\alpha, \beta) = \sum_{i=1}^N\alpha_i-\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i, x_j)\)</span></p><p>由<span class="math inline">\(\frac{1}{2}||\omega||^2 = \frac{1}{2}\omega^T\omega\)</span></p><p><span class="math inline">\(= \frac{1}{2}(\sum_{i=1}^N\alpha_iy_i\varphi(x_i))^T(\sum_{j=1}^N\alpha_jy_j\varphi(x_j))\)</span></p><p><span class="math inline">\(= \frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\varphi(x_i)^T\varphi(x_j)\)</span></p><p><span class="math inline">\(=\frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i, x_j)\)</span></p><p>这里用到了 <span class="math inline">\(K(x_i, x_j)=\varphi(x_i)^T\varphi(x_j)\)</span></p><p>注意到<span class="math inline">\(K(x_i, x_j)=K(x_j, x_i)\)</span></p><p><span class="math inline">\(- \sum_{i=1}^N\alpha_iy_i\omega^T\varphi(x_i)\)</span></p><p><span class="math inline">\(= -\sum_{i=1}^N\alpha_Iy_i(\sum_{j=1}^N\alpha_jy_j\varphi(x_j))^T\varphi(x_i)\)</span></p><p><span class="math inline">\(= -\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j\varphi(x_i)^T\varphi(x_j)\)</span></p><p><span class="math inline">\(= -\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i, x_j)\)</span></p><h3 id="结论">结论</h3><p>最大化：<span class="math inline">\(\theta(\alpha, \beta) = \sum_{i=1}^N\alpha_i - \frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i, x_j)\)</span></p><p>限制条件：<span class="math inline">\(\left\{\begin{matrix}\ 0 \leq \alpha_i \leq c \\ \sum_{i=1}^N\alpha_iy_i=0 \end{matrix}\right.\)</span></p><p><span class="math inline">\(KKT\)</span>条件：<span class="math inline">\(\forall i=1 \cdots K, \alpha_i^*=0或g_i^*(\omega^*) = 0\)</span></p><p>解法：<span class="math inline">\(SMO\)</span>算法</p><h3 id="参数求解">参数求解</h3><p>对于测试样本<span class="math inline">\(x\)</span>，<span class="math inline">\(\left\{\begin{matrix}\ 若\omega^T\varphi(x) + b \geq 0, 则y=+1 \\ 若\omega^T\varphi(x) + b &lt; 0, 则y=-1 \end{matrix}\right.\)</span></p><p>根据<span class="math inline">\(\omega^T\varphi(x) = \sum_{i=1}^N[\alpha_iy_i\varphi(x_i)]^T\varphi(x) \\ = \sum_{i=1}^N\alpha_iy_i[\varphi(x_i)]^T\varphi(x) \\ = \sum_{i=1}^N\alpha_iy_iK(x_i, x)\)</span></p><p>可知，不需要知道参数<span class="math inline">\(\omega\)</span>，只需要知道<span class="math inline">\(\alpha_i和K(x, y)\)</span></p><p>下面求解<span class="math inline">\(b\)</span>，根据<span class="math inline">\(KKT\)</span>条件，</p><p><span class="math inline">\(\forall i = 1 \cdots N\)</span>，<span class="math inline">\(\left\{\begin{matrix}\ 要么\beta_i=0，要么\xi_i=0 \\ 要么\alpha_i=0，要么1+\xi_i - y_i\omega^T\varphi(x_i) - y_ib = 0 \end{matrix}\right.\)</span></p><p>取一个<span class="math inline">\(0&lt;\alpha_i &lt; c \Rightarrow\)</span> <span class="math inline">\(\left\{\begin{matrix}\ \alpha_i \neq 0 \\ \beta_i = c - \alpha_I &gt; 0 \end{matrix}\right.\)</span> <span class="math inline">\(\Rightarrow \beta_i \neq 0 \Rightarrow \xi_i = 0\)</span></p><p><span class="math inline">\(\alpha_i \neq 0 \Rightarrow 1 - y_i\omega^T\varphi(x_i) - y_ib = 0 \\ \Rightarrow b = \frac{1 - y_i\omega^T\varphi(x_i)}{y_i} = \frac{1 - y_i\sum_{j = 1}^N\alpha_jy_jK(x_i, x_j)}{y_i}\)</span></p><h3 id="参考资料">参考资料：</h3><p>1、《Convex Optimization》 Stephen Boyd著，即《凸优化》</p><p>2、《Nonliner Programming》</p><h1 id="svm算法">SVM算法</h1><h2 id="训练流程">训练流程</h2><p>输入<span class="math inline">\((x_i, y_i), i= 1 \cdots N\)</span></p><p>解优化问题：</p><p>最大化：<span class="math inline">\(\theta(\alpha) = \sum_{i=1}^N\alpha_i - \frac{1}{2}\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jK(x_i, x_j)\)</span></p><p>限制条件：<span class="math inline">\(\left\{\begin{matrix}\ 0 \leq \alpha_i \leq c \\ \sum_{i=1}^N\alpha_iy_i=0 \end{matrix}\right.\)</span></p><p>使用<span class="math inline">\(SMO\)</span>算法求解出<span class="math inline">\(\alpha_i\)</span></p><p>求解<span class="math inline">\(b\)</span>：找一个<span class="math inline">\(0 &lt; \alpha_i &lt; c\)</span>，<span class="math inline">\(b = \frac{1 - y_i\sum_{j=1}^N\alpha_jy_jK(x_i, x_j)}{y_i}\)</span></p><h2 id="测试流程">测试流程</h2><p>输入测试样本<span class="math inline">\(x\)</span></p><p><span class="math inline">\(\left\{\begin{matrix}\ 若\sum_{i=1}^N\alpha_iy_iK(x_i, x) \geq 0, 则y=+1 \\ 若\sum_{i=1}^N\alpha_iy_iK(x_i, x) &lt; 0 则y=-1\end{matrix}\right.\)</span></p><h1 id="svm-核函数">SVM 核函数</h1><p><span class="math inline">\(Linear\)</span>（线性内核）：<span class="math inline">\(K(x, y) = x^Ty\)</span>（等于不用核函数）</p><p><span class="math inline">\(Poly\)</span>（多项式核）：<span class="math inline">\(K(x, y) = (x^Ty + 1)^d\)</span>（可以写出<span class="math inline">\(\varphi(x)\)</span>）</p><p><span class="math inline">\(Rbf\)</span>（高斯径向基函数核）：<span class="math inline">\(K(x, y) = e^-\frac{||x-y||^2}{\sigma^2}\)</span></p><p><span class="math inline">\(Tanh核\)</span>：<span class="math inline">\(K(x, y) = tanh(\beta x^Ty + b), tanh=\frac{e^x - e^{-x}}{e^x + e^{-x}}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>SVM</tag>
      
      <tag>支持向量机</tag>
      
      <tag>凸优化</tag>
      
      <tag>对偶问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划简单总结</title>
    <link href="/2022/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/09/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的动态规划题，当年写的时候真的老费劲了，也没有总结模型和技巧。碰到求最、恰好等等的题目，首先可以判断是否可以贪心，如果不行那可能只能动态规划了。</p><p>  动态规划（DP）的本质是什么？从各种算法书中可以了解到，<em>动态规划实际上是对有向无环图（DAG）的广度优先遍历（BFS）</em>。对于初学者而言，虽然我们知道DAG，也知道BFS，但是这个「本质」还是太抽象了，这里我们暂且不讨论。</p><p>  那么如何学好DP呢？由于我本人也是人菜瘾大，所以我还是选择听从各路大神的建议。</p><p>  首先，我们需要知道DP有哪些模型。</p><ul><li>数字三角形</li><li>最长上升子序列</li><li>背包DP</li><li>树状DP</li><li>状态机DP</li><li>状态压缩DP</li><li>区间DP</li><li>数位DP</li><li>斜率优化DP</li><li>单调队列优化DP</li></ul><p>  然后，找模板题，训练。这里需要熟知每一种模板的代码，达到盲打程度即可。（推荐<a href="https://www.acwing.com/">AcWing</a>，y总YYDS！）</p><p>  最后，刷题+总结。碰到题目先判断下可能用到哪种DP模型，然后再对应上去。这个过程极其艰辛。</p><p>下面列一下LC上的题。</p><h1 id="数字三角形">数字三角形</h1><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/triangle/">Leetcode-120.Triangle</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><p>样例：</p><p>For example, given the following triangle</p><p>[ [<strong>2</strong>], [<strong>3</strong>,4], [6,<strong>5</strong>,7], [4,<strong>1</strong>,8,3]]</p><p>The minimum path sum from top to bottom is <code>11</code> (i.e., <strong>2</strong> + <strong>3</strong> + <strong>5</strong> + <strong>1</strong> = 11).</p><p><strong>Note:</strong></p><p>Bonus point if you are able to do this using only <em>O</em>(<em>n</em>) extra space, where <em>n</em> is the total number of rows in the triangle.</p><p>题目大意：给定一个三角矩阵，选择一条自顶向下的路径，使得该路径经过的数字只和最小。注意，每往下走一步，只能走到相邻的格子。</p><h3 id="状态转移">状态转移</h3><p>  将该矩阵作为记忆化搜索的存储矩阵，从上往下、逐行遍历，每个元素选择上一行最小相邻元素相加，然后遍历最后一行元素取出最小值即可。</p><h3 id="代码">代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = triangle.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-comment">// 从第二行开始遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; triangle[i].<span class="hljs-built_in">size</span>(); ++j)&#123;<br>            <span class="hljs-comment">// 第二行单独处理 因为第一行只有一个元素            </span><br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">1</span>)&#123;<br>                triangle[i][j] += triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-comment">// 每行第一个元素单独处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-comment">// 每行最后一个元素也单独处理</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == triangle[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">// 其余元素有前驱也有后继</span><br>            <span class="hljs-comment">// 选择最小值相加</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                triangle[i][j] += triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] &lt; triangle[i - <span class="hljs-number">1</span>][j] ? triangle[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] : triangle[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 遍历最后一行 取出最小值</span><br>    <span class="hljs-keyword">int</span> minx = triangle[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt; triangle[n - <span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); ++k)&#123;<br>        <span class="hljs-keyword">if</span>(minx &gt; triangle[n - <span class="hljs-number">1</span>][k])<br>            minx = triangle[n - <span class="hljs-number">1</span>][k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> minx;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练">相关训练：</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/climbing-stairs/">Leetcode-70.Climbing Stairs</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/070-climbing-stairs/climbing-stairs.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Adobe</strong>；<strong>Apple</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/minimum-path-sum/">Leetcode-64.Minimum Path Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/064-minimum-path-sum/minimum-path-sum.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="记忆化搜索">记忆化搜索</h1><p>  有时候「记忆化搜索」比DP更容易想到，因为状态转移方程不容易推导。</p><h2 id="题目-1">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/integer-break/">Leetcode-343.Integer Break</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a positive integer <em>n</em>, break it into the sum of <strong>at least</strong> two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>样例1：</p><p><strong>Input:</strong> <code>2</code></p><p><strong>Output:</strong> <code>1</code></p><p><strong>Explanation:</strong> 2 = 1 + 1, 1 × 1 = 1.</p><p>样例2：</p><p><strong>Input:</strong> <code>10</code></p><p><strong>Output:</strong> <code>36</code></p><p><strong>Explanation:</strong> 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</p><p><strong>Note</strong>: You may assume that <em>n</em> is not less than 2 and not larger than 58.</p><p>题目大意：对一个正整数进行分割，获取分割后整数乘积的最大值。注意至少分割两次，至多不超过58次。</p><h3 id="解析">解析</h3><p>  这个问题可以找到<strong>最优子结构</strong>，考虑整数n的情况，若已知n-1的最优结果，则可以求出n的最优结果，当n=1时整数无法再继续分割（递归终止）。同时使用记忆化搜索对分割结果进行保存。</p><h3 id="实现代码">实现代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; vec;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(a, <span class="hljs-built_in">max</span>(b, c));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(vec[n] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> vec[n];<br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n - <span class="hljs-number">1</span>; ++ i)<br>            <span class="hljs-comment">// 保存最大值</span><br>            ret = <span class="hljs-built_in">max3</span>(ret, i * (n - i), i * <span class="hljs-built_in">dp</span>(n - i));<br>        vec[n] = ret;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">integerBreak</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        vec = vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dp</span>(n);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-1">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/perfect-squares/">Leetcode-279.Perfect Squares</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/279-perfect-squares/perfect-squares.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/decode-ways/">Leetcode-91.Decode Ways</a></td><td><a href="#Leetcode-91">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Uber</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/unique-paths/">Leetcode-62.Unique Paths</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/062-unique-paths/unique-paths.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/unique-paths-ii/">Leetcode-63.Unique Paths II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/063-unique-paths-ii/unique-paths-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr></tbody></table><div id="Leetcode-91"></div><p>Leetcode-91 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numDecodings</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">if</span>(s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(n + <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++ i)&#123;<br>            <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> || s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                    dp[i] = dp[i - <span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">else</span><br>                    dp[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                dp[i] = ((s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) || (s[i - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;2&#x27;</span> &amp;&amp; s[i - <span class="hljs-number">1</span>] &lt;= <span class="hljs-string">&#x27;6&#x27;</span>)) ? dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>] : dp[i - <span class="hljs-number">1</span>];<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[n];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="状态机模型">状态机模型</h1><h2 id="题目-2">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/house-robber/">Leetcode-198.House Robber</a></p><p><strong>Linkedin</strong>；<strong>Airbnb</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and <strong>it will automatically contact the police if two adjacent houses were broken into on the same night</strong>.</p><p>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight <strong>without alerting the police</strong>.</p><p>样例1：</p><p><strong>Input:</strong> <code>[1,2,3,1]</code></p><p><strong>Output:</strong> <code>4</code></p><p><strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4.</p><p>样例2：</p><p><strong>Input:</strong> <code>[2,7,9,3,1]</code></p><p><strong>Output:</strong> <code>12</code></p><p><strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12.</p><p>题目大意：给定数组nums，根据选取元素不能相邻的原则选出和为最大值的组合，求出这个最大值。</p><p>题目解析：给定数组nums[0,...,n - 1]，若第一次选择nums[0]，则下一步需要考虑nums[2,...,n - 1]；若选择的是nums[1]，则下一步考虑nums[3,...,n - 1]……</p><h2 id="状态定义">状态定义</h2><p>对函数的定义，考虑选择nums[i, ..., n - 1]</p><h2 id="状态转移-1">状态转移</h2><p><span class="math inline">\(F(0) = max(nums[0] + F(2), nums[1] + F(3),...，nums[n - 3] + F(n - 1), nums[n - 2], nums[n - 1])\)</span></p><h3 id="代码1">代码1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; dp;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">help</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> pos)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(pos &gt;= nums.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(dp[pos] != <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> dp[pos];<br><br>        <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 范围是nums[pos, ..., nums.size() - 1]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = pos; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)<br>            ret = <span class="hljs-built_in">max</span>(ret, nums[i] + <span class="hljs-built_in">help</span>(nums,i + <span class="hljs-number">2</span>));<br>        dp[pos] = ret;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        dp = vector&lt;<span class="hljs-keyword">int</span>&gt;(nums.<span class="hljs-built_in">size</span>(),<span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">help</span>(nums, <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="代码2">代码2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        dp[n - <span class="hljs-number">1</span>] = nums[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; n ; ++j)<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], nums[j] + ( j + <span class="hljs-number">2</span> &lt; n ? dp[j + <span class="hljs-number">2</span>] : <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-2">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/house-robber-ii/">Leetcode-213.House Robber II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/213-house-robber-ii/house-robber-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Microsoft</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/house-robber-iii/">Leetcode-337.House Robber III</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/337-house-robber-iii/house-robber-iii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Uber</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Leetcode-309.Best Time to Buy and Sell Stock with Cooldown</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/309-best-time-to-buy-and-sell-stock-with-cooldown/best-time-to-buy-and-sell-stock-with-cooldown.cpp">Solution-C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr></tbody></table><h1 id="背包模型">背包模型</h1><h2 id="背包">01背包</h2><p>  假设背包容量为<span class="math inline">\(C\)</span>，给定有限个物品序列<span class="math inline">\(w[w_0,...,w_{n - 1}]\)</span>，每个物品具有对应的价值<span class="math inline">\(v[v_0, ..., v_{n - 1}]\)</span>，可以选择放入背包或者不放入，找出使得放入背包后物品价值总和为最大值的组合，求出这个最大值。</p><h3 id="实现1">实现1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(C*n)</span><br><span class="hljs-comment">// memory: O(C*n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;w, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = w.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 使用二维数组存储搜索结果</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(C + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br>    <span class="hljs-comment">// 初始化第一行</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>        dp[<span class="hljs-number">0</span>][j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>            <span class="hljs-comment">// 选择不放入</span><br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// 若容量允许 选择放入</span><br>            <span class="hljs-comment">// 求出两种策略的最大值</span><br>            <span class="hljs-keyword">if</span>(j &gt;= w[i])<br>                dp[i][j] = <span class="hljs-built_in">max</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后一行最后一个元素即所求最大值</span><br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>][C];<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="实现2">实现2</h3><p>  时间复杂度为<span class="math inline">\(O(Cn)\)</span>无法优化，但是可以优化空间复杂度。方法：滚动数组/一维。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(C*n)</span><br><span class="hljs-comment">// memory: O(C)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">knapsack01</span><span class="hljs-params">(<span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;w, <span class="hljs-keyword">const</span> vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;v, <span class="hljs-keyword">int</span> C)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = w.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span>(!n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 使用一维数组存储</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(C + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-comment">// 初始化“第一行“</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)&#123;<br>        dp[j] = (j &gt;= w[<span class="hljs-number">0</span>] ? v[<span class="hljs-number">0</span>] : <span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>        <span class="hljs-comment">// 这里每行是从后往前搜索</span><br>        <span class="hljs-comment">// 先更新后面的元素是因为计算时要用到前面的元素，切记</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = C; j &gt;= w[i]; -- j)&#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个元素为最大值</span><br>    <span class="hljs-keyword">return</span> dp[C];<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="题目2">题目2</h2><p>问题来源：<a href="https://leetcode.com/problems/partition-equal-subset-sum/">Leetcode-416.Partition Equal Subset Sum</a></p><p><strong>Ebay</strong></p><p>问题难度：<strong>Medium</strong></p><p>问题描述：Given a <strong>non-empty</strong> array containing <strong>only positive integers</strong>, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p><p><strong>Note:</strong></p><ol type="1"><li>Each of the array element will not exceed 100.</li><li>The array size will not exceed 200.</li></ol><p>样例1：</p><p><strong>Input</strong>: <code>[1, 5, 11, 5]</code></p><p><strong>Output</strong>: <code>true</code></p><p><strong>Explanation</strong>: The array can be partitioned as [1, 5, 5] and [11].</p><p>样例2：</p><p><strong>Input</strong>: <code>[1, 2, 3, 5]</code></p><p><strong>Output</strong>: <code>false</code></p><p><strong>Explanation</strong>: The array cannot be partitioned into equal sum subsets.</p><p>问题大意：给定n个数字，它们的和为sum，选出一定物品使得容量为sum/2</p><h3 id="实现代码-1">实现代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">canPartition</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; num: nums) sum += num;<br>        <span class="hljs-keyword">if</span>(sum % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>(), C = sum / <span class="hljs-number">2</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(C + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= C; ++ j)<br>            dp[j] = (nums[<span class="hljs-number">0</span>] == j);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = C; j &gt;= nums[i]; -- j)&#123;<br>                <span class="hljs-comment">// 不使用或使用nums[i]</span><br>                dp[j] = dp[j] || dp[j - nums[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[C];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练-3">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/coin-change/">Leetcode-322.Coin Change</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/322-coin-change/coin-change.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/combination-sum-iv/">Leetcode-377.Combination Sum IV</a></td><td><a href="#Leetcode-377">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Google</strong>；<strong>Snapchat</strong></td></tr><tr class="odd"><td><a href="%5BOnes%20and%20Zeroes%5D(https://leetcode-cn.com/problems/ones-and-zeroes/)">Leetcode-474.Ones and Zeros</a></td><td></td><td><strong>Medium</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/word-break/">Leetcode-139.Word Break</a></td><td></td><td><strong>Medium</strong></td><td><strong>Google</strong>；<strong>Facebook</strong>;<strong>Amazon</strong>;<strong>Uber</strong>;<strong>Bloomberg</strong>;<strong>PocketGems</strong>;<strong>Yahoo</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/target-sum/">Leetcode-494.Target Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/494-target-sum/target-sum.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Google</strong>；<strong>Facebook</strong></td></tr></tbody></table><div id="Leetcode-377"></div><p>Leetcode-377 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">combinationSum4</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; target + <span class="hljs-number">1</span>; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>                <span class="hljs-keyword">if</span>(nums[j] &lt;= i)<br>                    dp[i] = dp[i] + dp[i - nums[j]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[target];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="最长上升子序列模型">最长上升子序列模型</h1><h2 id="题目-3">题目</h2><p>问题来源：<a href="https://leetcode.com/problems/longest-increasing-subsequence/">Leetcode-300.Longest Increasing Subsequence</a></p><p><strong>Microsoft</strong></p><p>问题难度：<strong>Medium</strong></p><p>问题描述：Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>样例：</p><p><strong>Input:</strong> <code>[10,9,2,5,3,7,101,18]</code></p><p><strong>Output:</strong> <code>4</code></p><p><strong>Explanation:</strong> The longest increasing subsequence is <code>[2,3,7,101]</code>, therefore the length is <code>4</code>.</p><p>问题大意：给定一个整数序列nums[], 求出其中最长上升子序列的长度。</p><h3 id="解析-1">解析：</h3><p><strong>最长上升子序列</strong>（<strong>LIS</strong>）问题。设置状态<em>LIS(i)</em>为第i个数字为结尾的最长上升子序列的长度。那么<em>LIS(i)</em>表示nums[0, ..., i]内，选择nums[i]可以获得的最长上升子序列的长度。</p><h3 id="状态转移方程">状态转移方程</h3><p><span class="math inline">\(f[i] = max(f[j] + 1 {\,} if{\,}j &lt; i{\,}and{\,}nums[i] &gt; nums[j], f[i])\)</span></p><h3 id="代码1-1">代码1:</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 每个单独序列本身长度为1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; -- j)&#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j])&#123;<br>                    dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>                    maxn = <span class="hljs-built_in">max</span>(dp[i], maxn);<br>                    <span class="hljs-comment">// 这一步的搜索必须将前面的数字都扫描一遍</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="代码2-1">代码2:</h3><p>  设置一个最长子序列dp[]，遍历nums[]，若nums[i]大于dp[]最后一个元素则末尾添加，否则在dp[]中找到适合nums[i]插入的位置，使得nums[i]替换刚好比它大的dp[j]。dp的长度即最长子序列的长度。</p><p>  由于dp是有序的，所以可以使用二分查找法。并且插入操作实际上是替换，所以总的时间复杂度为<em>O(nlogn)</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(!n || n == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++ i)&#123;<br>            <span class="hljs-keyword">if</span>(dp[len - <span class="hljs-number">1</span>] &lt; nums[i])&#123;<br>                dp[len ++] = nums[i];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// lower_bound最好自己实现一下.</span><br>                <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">lower_bound</span>(dp.<span class="hljs-built_in">begin</span>(), dp.<span class="hljs-built_in">begin</span>() + len, nums[i]);<br>                * it = nums[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-4">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/wiggle-subsequence/">Leetcode-376.Wiggle Subsequence</a></td><td></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h2 id="题目2-1">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/longest-common-subsequence/">Leetcode-1143.Longest Common Subsequence</a></p><p>题目难度：Medium</p><p>题目描述：Given two strings <code>text1</code> and <code>text2</code>, return the length of their longest common subsequence.</p><p>A <em>subsequence</em> of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A <em>common subsequence</em> of two strings is a subsequence that is common to both strings.</p><p>If there is no common subsequence, return 0.</p><p>样例1：</p><p><strong>Input:</strong> text1 = "abcde", text2 = "ace"</p><p><strong>Output:</strong> 3</p><p><strong>Explanation:</strong> The longest common subsequence is "ace" and its length is 3.</p><p>样例2：</p><p><strong>Input:</strong> text1 = "abc", text2 = "abc"</p><p><strong>Output:</strong> 3</p><p><strong>Explanation:</strong> The longest common subsequence is "abc" and its length is 3.</p><p>样例3：</p><p><strong>Input:</strong> text1 = "abc", text2 = "def"</p><p><strong>Output:</strong> 0</p><p><strong>Explanation:</strong> There is no such common subsequence, so the result is 0.</p><p>题目大意：给定两个字符串s1和s2，求出它们的最长公共字串的长度。</p><h3 id="解析-2">解析</h3><p>  这是一道动态规划的经典问题，我们可以定义状态<strong>LCS(i, j)</strong>, i表示s1的索引，j表示s2的索引。LCS存储的是s1[0,...,i - 1]和s2[0, ..., j - 1]的最长公共字串的长度。状态转移方程如下：</p><p><span class="math display">\[LCS(i,j)=\begin{cases}LCS(i - 1, j - 1)\:, if\:s1[i] == s2[i] \\max(LCS(i - 1, j)\:, LCS(i, j - 1)),if\:s1[i] != s2[j]\end{cases}\]</span></p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(string &amp;text1, <span class="hljs-keyword">const</span> string &amp;text2)</span></span>&#123;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(text1.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, vector&lt;<span class="hljs-keyword">int</span>&gt;(text2.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 这里要从1开始 因为初始为0</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= text1.<span class="hljs-built_in">size</span>(); ++ i)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= text2.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>                <span class="hljs-keyword">if</span>(text1[i - <span class="hljs-number">1</span>] == text2[j - <span class="hljs-number">1</span>])&#123;<br>                    dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;item: dp)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp; it: item)&#123;<br>                maxn = <span class="hljs-built_in">max</span>(maxn, it);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxn;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/longest-palindromic-substring/">Leetcode-5.Longest Palindromic Substring</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a string <strong>s</strong>, find the longest palindromic substring in <strong>s</strong>. You may assume that the maximum length of <strong>s</strong> is 1000.</p><p>样例1：</p><p><strong>Input:</strong> <code>"babad"</code></p><p><strong>Output:</strong> <code>"bab"</code></p><p><strong>Note:</strong> "aba" is also a valid answer.</p><p>样例2：</p><p><strong>Input:</strong> <code>"cbbd"</code></p><p><strong>Output:</strong> <code>"bb"</code></p><p>题目大意：给定一个字符串s，求出该字符串的最长回文字串。</p><h3 id="状态定义-1">状态定义</h3><p>定义状态<em>dp(i，j)</em> ，表示子串s[i，j]是否为回文串，值为True时为回文串。</p><h3 id="状态转移方程-1">状态转移方程</h3><p><span class="math display">\[dp(i, j)=\begin{cases}True, s[i]==s[j]) \\s[i] == s[j], i == j + 1 \\s[i] == s[j]\:and\:dp(j + 1,i-1)\end{cases}\]</span></p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><span class="hljs-comment">// Leetcode耗时400ms</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>() &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> s;<br>        vector&lt;vector&lt;<span class="hljs-keyword">bool</span>&gt;&gt; <span class="hljs-built_in">dp</span>(s.<span class="hljs-built_in">size</span>(), vector&lt;<span class="hljs-keyword">bool</span>&gt;(s.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>));<br>        <span class="hljs-function">string <span class="hljs-title">res</span><span class="hljs-params">(s.begin(), s.begin() + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; s.<span class="hljs-built_in">size</span>(); ++ j)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= j; ++ i)&#123;<br>                dp[i][j] = s[i] == s[j] &amp;&amp; (j - i &lt;= <span class="hljs-number">2</span> || dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                <span class="hljs-keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="hljs-number">1</span> &gt; res.<span class="hljs-built_in">size</span>())&#123;<br>                    res = <span class="hljs-built_in">string</span>(s.<span class="hljs-built_in">begin</span>() + i, s.<span class="hljs-built_in">begin</span>() + j + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>动态规划</tag>
      
      <tag>数字三角形</tag>
      
      <tag>背包问题</tag>
      
      <tag>最长上升子序列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查找问题</title>
    <link href="/2022/03/09/%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/09/%E6%9F%A5%E6%89%BE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的一些查找类型的题目。</p><h1 id="双指针">双指针</h1><p>  显然，用一个指针可以遍历线性表。但是为了解决一些问题，有时候可以考虑「双指针」，代码的实现更高效。</p><div id="Leetcode-167"></div><h2 id="题目1">题目1</h2><p>题目来源：<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">Leetcode-167.Two Sum II - Input array is sorted</a></p><p><strong>Amazon</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p><p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</p><p><strong>Note:</strong></p><ul><li>Your returned answers (both index1 and index2) are not zero-based.</li><li>You may assume that each input would have <em>exactly</em> one solution and you may not use the <em>same</em> element twice.</li></ul><p>题目大意：给定有序数组numbers[]和整数target，在numbers[]中寻找两个数使其和为target，并返回这两个数的索引。</p><p>样例：</p><p><strong>Input:</strong> numbers = <code>[2,7,11,15]</code>, target = <code>9</code></p><p><strong>Output:</strong> <code>[1,2]</code></p><p><strong>Explanation:</strong> The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</p><h3 id="暴力解法">暴力解法</h3><p>  实在想不出更高效的解法时，可以考虑暴力解法。其实很多优化也是从暴力开始进行的。</p><p>  时间复杂度为<span class="math inline">\(O(n^2)\)</span>，Leetcode提交超时。</p><h3 id="双指针-1">双指针</h3><p>  由于这是一个有序数组，所以可以使用两个指针index1和index2，一首一尾，根据此时指向元素的求和情况改变指针的指向。若numbers[index1] + numbers[index2] &lt; target，则index1++；大于则index2--；等于则有解。当index1与index2相遇时仍没有解则无解。</p><p>  需要注意的问题：不能返回相同的索引；要处理没有解的情况；若多解该如何处理？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time:O(n)</span><br><span class="hljs-comment">// memory:O(1)</span><br><span class="hljs-comment">// 充分利用numbers[]有序的特征</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; vt;<br>        <span class="hljs-keyword">int</span> index1 = <span class="hljs-number">0</span>,index2 = numbers.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index1 &lt; index2)&#123;<br>            <span class="hljs-keyword">if</span>(numbers[index1] + numbers[index2] == target)&#123;<br>                vt.<span class="hljs-built_in">push_back</span>(index1 + <span class="hljs-number">1</span>);<br>                vt.<span class="hljs-built_in">push_back</span>(index2 + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(numbers[index1] + numbers[index2] &gt; target)&#123;<br>                -- index2;<br>            &#125;<br>            <span class="hljs-keyword">else</span> ++ index1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="相关训练">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/valid-palindrome/">Leetcode-125.Valid Palindrome</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/125-valid-palindrome/valid-palindrome.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Uber</strong>；<strong>Zenefits</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/reverse-string/">Leetcode-344.Reverse String</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/344-reverse-string/reverse-string.cpp">C++</a></td><td><strong>Easy</strong></td><td></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/">Leetcode-345.Reverse Vowels of a String</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/345-reverse-vowels-of-a-string/reverse-vowels-of-a-string.java">Java</a></td><td><strong>Easy</strong></td><td><strong>Google</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/container-with-most-water/">Leetcode-11.Container With Most Water</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/011-container-with-most-water/container-with-most-water.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr></tbody></table><h2 id="题目2">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/two-sum/">Leetcode-1. Two Sum</a></p><p><strong>Facebook</strong>；<strong>Uber</strong>；<strong>Linkedin</strong>；<strong>Apple</strong>；<strong>Amazon</strong>；<strong>Microsoft</strong>；</p><p><strong>Yahoo</strong>；<strong>Yelp</strong>；<strong>Airbnb</strong>；<strong>Dropbox</strong>；<strong>Bloomberg</strong>；<strong>Adobe</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given an array of integers, return <strong>indices</strong> of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have <strong><em>exactly</em></strong> one solution, and you may not use the <em>same</em>element twice.</p><p>样例：</p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[<strong>0</strong>] + nums[<strong>1</strong>] = 2 + 7 = 9, return [<strong>0</strong>, <strong>1</strong>].</p><h3 id="暴力解法-1">暴力解法</h3><p>  双重循环，时间复杂度为<span class="math inline">\(O(n^2)\)</span>。提交超时。</p><h3 id="排序双索引对撞">排序+双索引对撞</h3><p>  先对数组nums按照索引进行排序，然后使用「双指针」。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p1, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; p2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> p1.second &lt; p2.second;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt; vec;<br>        <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++ i)&#123;<br>            vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i, nums[i]));<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(vec.<span class="hljs-built_in">begin</span>(), vec.<span class="hljs-built_in">end</span>(), cmp);<br>        <span class="hljs-keyword">int</span> idx1 = <span class="hljs-number">0</span>, idx2 = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(idx1 &lt; idx2)&#123;<br>            <span class="hljs-keyword">if</span>(vec[idx1].second + vec[idx2].second == target)&#123;<br>                res[<span class="hljs-number">0</span>] = vec[idx1].first;<br>                res[<span class="hljs-number">1</span>] = vec[idx2].first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(vec[idx1].second + vec[idx2].second &gt; target)<br>                -- idx2;<br>            <span class="hljs-keyword">else</span><br>                ++ idx1;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="二分查找">二分查找</h1><p>  刚才的题目<a href="#Leetcode-167">Leetcode-167</a>，由于给定的数组是有序的，所以可以用二分查找解决。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-comment">// 利用有序特征</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 二分查找</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp; nums, <span class="hljs-keyword">int</span> lt, <span class="hljs-keyword">int</span> gt, <span class="hljs-keyword">int</span> t)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(lt &lt;= gt)&#123;<br>            <span class="hljs-keyword">int</span> mid = lt + (gt - lt) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 防止溢出</span><br>            <span class="hljs-keyword">if</span>(nums[mid] &lt; t)&#123;<br>                lt = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &gt; t)&#123;<br>                gt = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; numbers, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt; res;<br>        <span class="hljs-keyword">int</span> n = numbers.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++ i)&#123;<br>            <span class="hljs-comment">// 查找numbers[j] == target - numbers[i]</span><br>            <span class="hljs-keyword">int</span> j = <span class="hljs-built_in">binarySearch</span>(numbers, i + <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>, target - numbers[i]);<br>            <span class="hljs-keyword">if</span>(j != <span class="hljs-number">-1</span>)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>                res.<span class="hljs-built_in">push_back</span>(j + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="关于二分查找其他模板">关于二分查找其他模板</h2><p>给定有序数组nums[N], 大小为n，数组下标从1开始，数组元素按照非降序排序。数组中有重复元素。</p><h3 id="查找元素为x的下标">查找元素为x的下标</h3><p>多解的情况返回一个即可。查找不到返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] == x)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid] &gt; x)&#123;<br>            l = mid - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找大于等于x的第一个元素的下标">查找大于等于x的第一个元素的下标</h3><p>条件同上，不存在返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] &gt;= x)&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[l] == x ? l : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="查找大于x的第一个元素的下标">查找大于x的第一个元素的下标</h3><p>条件同上，不存在返回-1。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr, <span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> x)</span></span><br><span class="hljs-function">    <span class="hljs-keyword">int</span> l </span>= <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(arr[mid] &gt; x)&#123;<br>            r = mid;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr[l] &gt; x ? l : <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="哈希表">哈希表</h1><p>C++的STL中的<em>unordered_map</em>底层实现是哈希表。（<del>当然自己手搓一个也可以</del>）</p><h2 id="题目1-1">题目1</h2><p><a href="https://leetcode.com/problems/two-sum/">Leetcode-1. Two Sum</a>。</p><p>将nums放入<strong>unordered_map</strong>中，对每一个元素nums[i]，查找target-nums[i]是否存在。</p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; m;<br>        vector&lt;<span class="hljs-keyword">int</span>&gt;res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++ i)&#123;<br>            m[nums[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; nums.<span class="hljs-built_in">size</span>();++ i)&#123;<br>            <span class="hljs-keyword">int</span> t = target - nums[i];<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">count</span>(t) &amp;&amp; m[t] != i)&#123;<br>                res.<span class="hljs-built_in">push_back</span>(i);<br>                res.<span class="hljs-built_in">push_back</span>(m[t]);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目2-1">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/4sum-ii/">Leetcode-454. 4Sum II</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given four lists A, B, C, D of integer values, compute how many tuples <code>(i, j, k, l)</code> there are such that <code>A[i] + B[j] + C[k] + D[l]</code> is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p>样例：</p><p><strong>Input:</strong> A = [ 1, 2] B = [-2,-1] C = [-1, 2] D = [ 0, 2]</p><p><strong>Output:</strong> 2</p><p><strong>Explanation:</strong> The two tuples are:</p><ol type="1"><li>(0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</li><li>(1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</li></ol><p>题目大意：给定四个整型数组A、B、C和D，寻找使得A[i]+B[j]+C[k]+D[l]==0的组合数。</p><h3 id="暴力解法-2">暴力解法</h3><p>四重循环，时间复杂度为O(n^4)，提交必然超时。</p><h3 id="mapunordered_map">map/unordered_map</h3><p>考虑将D放入查找表中，时间复杂度降为<span class="math inline">\(O(n^3)\)</span></p><p>将C+D放入查找表，时间复杂度降为<span class="math inline">\(O(n^2)\)</span></p><p>注意：B+C+D都放？那就是<span class="math inline">\(O(n^3)\)</span>了</p><p>这里实际上是对查找表的键值对进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n^2)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; A, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; B, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; C, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; D)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mpt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> c: C)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> d : D)<br>                ++ mpt[c + d];<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> a: A)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> b: B)<br>                <span class="hljs-keyword">if</span>(mpt.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-a-b)!=mpt.<span class="hljs-built_in">end</span>())<br>                    res += mpt[<span class="hljs-number">0</span> - a - b];<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-1">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/group-anagrams/">Leetcode-49.Group Anagrams</a></td><td><a href="#Leetcode-49">Solution</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong>；<strong>Uber</strong>；<strong>Bloomberg</strong>；<strong>Yelp</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/3sum/">Leetcode-15. 3Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/015-3sum/3sum.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong>；<strong>Microsoft</strong>；<strong>Bloomberg</strong>；<strong>Adobe</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/4sum/">Leetcode-18. 4Sum</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/018-4sum/4sum.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/3sum-closest/">Leetcode-16. 3Sum Closest</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/016-3sum-closest/3sum-closest.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Bloomberg</strong></td></tr></tbody></table><div id="Leetcode-49"></div><p>Leetcode-49 Solution</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//加速cin,cout</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">auto</span> _ = [] &#123;<br>    std::ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;();<br><br><span class="hljs-comment">// time: O(nlogs) s为最大字符串长度</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;<br>        vector&lt;vector&lt;string&gt;&gt; res;<br>        unordered_map&lt;string, <span class="hljs-keyword">int</span>&gt; mpt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;str: strs)&#123;<br>            string s = str;<br>            <span class="hljs-built_in">sort</span>(s.<span class="hljs-built_in">begin</span>(), s.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">if</span>(!mpt.<span class="hljs-built_in">count</span>(s))&#123;<br>                mpt[s] = res.<span class="hljs-built_in">size</span>();<br>                vector&lt;string&gt; r;<br>                res.<span class="hljs-built_in">push_back</span>(r);<br>            &#125;<br>            res[mpt[s]].<span class="hljs-built_in">push_back</span>(str);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目3">题目3</h2><p>题目来源：<a href="https://leetcode.com/problems/number-of-boomerangs/">Leetcode-447. Number of Boomerangs</a></p><p><strong>Google</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Given <em>n</em> points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points <code>(i, j, k)</code> such that the distance between <code>i</code> and <code>j</code> equals the distance between <code>i</code> and <code>k</code> (<strong>the order of the tuple matters</strong>).</p><p>Find the number of boomerangs. You may assume that <em>n</em> will be at most <strong>500</strong> and coordinates of points are all in the range <strong>[-10000, 10000]</strong> (inclusive).</p><p>样例：</p><p><strong>Input:</strong> <code>[[0,0],[1,0],[2,0]]</code></p><p><strong>Output:</strong> <code>2</code></p><p><strong>Explanation:</strong> The two boomerangs are <strong>[[1,0],[0,0],[2,0]]</strong> and <strong>[[1,0],[2,0],[0,0]]</strong></p><p>题目大意：给出平面上n个点，寻找使得i,j两点距离等于i,k两点距离的三元组(i,j,k)的个数。n最大值为<strong>500</strong>，点坐标范围为<strong>[-10000, 10000]</strong>。</p><h3 id="暴力解法-3">暴力解法</h3><p>三重循环。时间复杂度为O(n^3)。</p><h3 id="unordered_map">unordered_map</h3><p>双重遍历points，计算points[i] 与points[j]之间的距离放入查找表中。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(n)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 这里计算“距离“，不进行开方（避免出现浮点数）</span><br>    <span class="hljs-comment">// 计算distance可能会超出int范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dis</span><span class="hljs-params">(<span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp;pa, <span class="hljs-keyword">const</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&amp;pb)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> (pa.first - pb.first) * (pa.first - pb.first) + (pa.second - pb.second) * (pa.second - pb.second);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(vector&lt;pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; points.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; mpt;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; points.<span class="hljs-built_in">size</span>(); ++j)<br>                <span class="hljs-keyword">if</span>(j != i)<br>                    ++ mpt[<span class="hljs-built_in">dis</span>(points[i],points[j])];<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> it = mpt.<span class="hljs-built_in">begin</span>(); it != mpt.<span class="hljs-built_in">end</span>(); ++it)&#123;<br>                <span class="hljs-keyword">if</span>(it-&gt;second &gt;= <span class="hljs-number">2</span>)<br>                    <span class="hljs-comment">// 选择计数</span><br>                    res += (it-&gt;second) * (it-&gt;second - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-2">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/max-points-on-a-line/">Leetcode-149.Max Points on a Line</a></td><td></td><td><strong>Hard</strong></td><td><strong>Linkedin</strong>；<strong>Twitter</strong>；<strong>Apple</strong></td></tr></tbody></table><p>题目难度：</p><h1 id="滑动窗口">滑动窗口</h1><p>  滑动窗口的核心是维护长度一定的区间（窗口），窗口向前滑动时，只需修改少量信息。通常能将时间复杂度降低至<span class="math inline">\(O(n)\)</span>。</p><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/contains-duplicate-ii/">Leetcode-219.Contains Duplicate II</a></p><p><strong>Airbnb</strong>；<strong>Palantir</strong></p><p>题目描述：Given an array of integers and an integer <em>k</em>, find out whether there are two distinct indices <em>i</em> and <em>j</em>in the array such that <strong>nums[i] = nums[j]</strong> and the <strong>absolute</strong> difference between <em>i</em> and <em>j</em> is at most <em>k</em>.</p><p>样例：</p><p><strong>Input:</strong> nums = [1,2,3,1], k = 3 <strong>Output:</strong> true</p><p><strong>Input:</strong> nums = [1,0,1,1], k = 1 <strong>Output:</strong> true</p><p><strong>Input:</strong> nums = [1,2,3,1,2,3], k = 2 <strong>Output:</strong> false</p><p>题目大意：给定数组nums，找到nums[i] == nums[j]，索引i和j的差值不超过k。</p><h3 id="滑动窗口unordered_set">滑动窗口+unordered_set</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(k)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-keyword">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">find</span>(nums[i]) != st.<span class="hljs-built_in">end</span>())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            st.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">size</span>() == k + <span class="hljs-number">1</span>)<br>                st.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-3">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/contains-duplicate/">Leetcode-217.Contains Duplicate</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/217-contains-duplicate/contains-duplicate.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Airbnb</strong>；<strong>Palantir</strong>；<strong>Yahoo</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/contains-duplicate-iii/">Leetcode-220.Contains Duplicate III</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/220-contains-duplicate-iii/contains-duplicate-iii.cpp">C++</a></td><td><strong>Medium</strong></td><td><strong>Airbnb</strong>；<strong>Palantir</strong></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>查找</tag>
      
      <tag>二分</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表技巧</title>
    <link href="/2022/03/09/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/03/09/%E9%93%BE%E8%A1%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="写在前面">写在前面</h1><p>  LeetCode中的简单链表题，简单，但是可以有一些常用的小技巧。</p><h1 id="创建虚拟头结点">创建虚拟头结点</h1><p>  LeetCode通常会给出单链表，头节点也会存信息，常常需要对头节点特判，增加了冗余代码。</p><p>  这时候可以考虑增加一个虚拟头节点，指向题目给的单链表，然后就不需要特判了。</p><h2 id="题目1">题目1</h2><p>题目来源：<a href="https://leetcode.com/problems/remove-linked-list-elements/">Leetcode-203.Remove Linked List Elements</a></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Remove all elements from a linked list of integers that have value <strong><em>val</em></strong>.</p><p>样例：</p><p><strong>Input:</strong> <code>1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6</code>, <strong><em>val</em></strong> = <code>6</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code></p><p>题目大意：给定一个链表，删除值为val的结点。</p><h3 id="解析">解析</h3><p>  删除的结点可能是头结点，所以要设立一个虚拟的头结点，然后使用三个指针来遍历链表即可。删除链表结点：前驱结点的next指向后继结点。</p><p>  很明显，因为头结点也会被操作，所以此类问题最好设置虚拟的头结点，使得原来的头结点和其他结点一样，都有前驱，不必为头结点特别操作。</p><h3 id="代码">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><span class="hljs-comment">// 链表结点定义省略</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        ListNode* vihead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        vihead-&gt;next = head;<br>        ListNode *pre = vihead, *cur = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val == val)&#123;<br>                pre-&gt;next = cur-&gt;next;<br>                cur = pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                pre = cur;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> vihead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="题目2">题目2</h2><p>题目来源：<a href="https://leetcode.com/problems/swap-nodes-in-pairs/">Leetcode-24.Swap Nodes in Pairs</a></p><p><strong>Microsoft</strong>；<strong>Bloomberg</strong>；<strong>Uber</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a linked list, swap every two adjacent nodes and return its head.</p><p>You may <strong>not</strong> modify the values in the list's nodes, only nodes itself may be changed.</p><p>样例：</p><p>Given <code>1-&gt;2-&gt;3-&gt;4</code>, you should return the list as <code>2-&gt;1-&gt;4-&gt;3</code>.</p><h3 id="解析-1">解析</h3><p>  类似地，本题也需要创建虚拟头结点。所谓交换结点不过也是一种对链表的基本操作。</p><h3 id="代码-1">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode *nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        ListNode *p = nhead;<br>        <span class="hljs-keyword">while</span>(p-&gt;next&amp;&amp;p-&gt;next-&gt;next)&#123;<br>            ListNode *n1 = p-&gt;next, *n2 = n1-&gt;next;<br>            ListNode *next = n2-&gt;next;<br>            n2-&gt;next = n1;<br>            n1-&gt;next = next;<br>            p-&gt;next = n2;<br>            p = n1;<br>        &#125;<br>        <span class="hljs-comment">//return nhead-&gt;next;</span><br>        <span class="hljs-comment">// 删除虚拟头结点</span><br>        <span class="hljs-keyword">auto</span> res = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;        <br>        <span class="hljs-comment">// 返回真实头结点</span><br>        <span class="hljs-keyword">return</span> res;    <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><p>  其实所有的链表题都可以加个虚拟头节点（<del>这个甚至都不能算是技巧了</del>）。</p><h3 id="相关训练">相关训练</h3><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/">Leetcode-82.Remove Duplicates from Sorted List II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/082-remove-duplicates-from-sorted-list-ii/remove-duplicates-from-sorted-list-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/merge-two-sorted-lists/">Leetcode-21.Merge Two Sorted Lists</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/021-merge-two-sorted-lists/merge-two-sorted-lists.cpp">C++</a> <a href="https://github.com/yangyangu/MyLeetCode/blob/master/021-merge-two-sorted-lists/merge-two-sorted-lists.java">Java</a></td><td><strong>Easy</strong></td><td><strong>Amazon</strong>；<strong>Linkedin</strong>；<strong>Microsfot</strong>；<strong>Apple</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/">Leetcode-25.Reverse Nodes in k-Group</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/025-reverse-nodes-in-k-group/reverse-nodes-in-k-group.cpp">C++</a></td><td><strong>Hard</strong></td><td><strong>Facebook</strong>；<strong>Microsoft</strong></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/delete-node-in-a-linked-list/">Leetcode-237.Delete Node in a Linked List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/237-delete-node-in-a-linked-list/delete-node-in-a-linked-list.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Microsoft</strong>；<strong>Adobe</strong>；<strong>Apple</strong></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/insertion-sort-list/">Leetcode-147.Insertion Sort List</a></td><td><a href="#List-Sort">链表排序</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="">Leetcode-148.Sort List</a>https://leetcode.com/problems/sort-list/</td><td><a href="#List-Sort">链表排序</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="链表双指针">链表双指针</h1><p>  双指针无论是在数组还是在链表中都是很常用的技巧。</p><h2 id="题目">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">Leetcode-19.Remove Nth Node From End of List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p><p>样例：</p><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.</p><p>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p><p>题目大意：给定一个链表，删除倒数第n个结点。</p><p>Note：题目保证n是合法的。注意《剑指offer》中也有此题，但是不保证n的合法性，所以要自行处理。</p><h3 id="两次遍历">两次遍历</h3><p>第一次遍历获取链表长度；第二次遍历删除倒数第n个结点。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head-&gt;next) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode *pre = head, *cur = head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cur = cur-&gt;next;<br>        <span class="hljs-keyword">if</span> (!cur) <span class="hljs-keyword">return</span> head-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next) &#123;<br>            cur = cur-&gt;next;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 删除p的后继</span><br>        <span class="hljs-keyword">auto</span> next = p-&gt;next;<br>        pre-&gt;next = pre-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> next;<br><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="使用双指针一次遍历">使用双指针：一次遍历</h3><p>使用两个指针p和q， p指向头结点，同时p和q在链表中的距离为n，那么同时将p和q向后移动直到q到达尾结点，此时p恰好为倒数第n + 1个结点。删除p的后继结点即可。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// momory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">// 使用虚拟头结点</span><br>        ListNode *nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        ListNode *p = nhead, *q = nhead;<br>        <span class="hljs-comment">// 使得p和q相距为n</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; ++i)<br>            q = q-&gt;next;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">nullptr</span>)&#123;<br>            p = p-&gt;next;<br>            q = q-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 删除p的后继</span><br>        <span class="hljs-keyword">auto</span> next = p-&gt;next;<br>        p-&gt;next = p-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> next;<br><br>        <span class="hljs-comment">// 删除虚拟头结点并返回头指针</span><br>        <span class="hljs-keyword">auto</span> res = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-1">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/rotate-list/">Leetcode-61.Rotate List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/061-rotate-list/rotate-list.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr><tr class="even"><td><a href="https://leetcode.com/problems/reorder-list/">Leetcode-143.Reorder List</a></td><td></td><td><strong>Medium</strong></td><td></td></tr><tr class="odd"><td><a href="https://leetcode.com/problems/palindrome-linked-list/">Leetcode-234.Palindrome Linked List</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/234-palindrome-linked-list/palindrome-linked-list.cpp">C++</a></td><td><strong>Easy</strong></td><td><strong>Facebook</strong>；<strong>Amazon</strong></td></tr></tbody></table><div id="List-Sort"></div><h1 id="链表排序">链表排序</h1><p>  把链表存到数组排序的解法不算数！</p><h2 id="插入排序insertion-sort">插入排序(Insertion Sort)</h2><p>题目来源：<a href="https://leetcode.com/problems/insertion-sort-list/">Leetcode-147.Insertion Sort List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Sort a linked list using insertion sort.</p><p>样例1：</p><p><strong>Input:</strong> <code>4-&gt;2-&gt;1-&gt;3</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4</code></p><p>样例1：</p><p><strong>Input:</strong> <code>-1-&gt;5-&gt;3-&gt;4-&gt;0</code></p><p><strong>Output:</strong> <code>-1-&gt;0-&gt;3-&gt;4-&gt;5</code></p><h3 id="代码-2">代码</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n^2)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> nhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        nhead-&gt;next = head;<br>        <span class="hljs-keyword">auto</span> cur = head-&gt;next, prev = head;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &gt; prev-&gt;val)&#123;<br>                <span class="hljs-comment">// 当前元素与前驱元素相对有序</span><br>                prev = cur;<br>                cur = cur-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// 当前元素与前驱元素无序</span><br>                <span class="hljs-keyword">auto</span> ptr_pre = nhead, ptr = nhead-&gt;next;<br>                <span class="hljs-comment">// 在头结点-前驱元素区间找到插入点</span><br>                <span class="hljs-keyword">while</span>(ptr != cur &amp;&amp; cur-&gt;val &gt; ptr-&gt;val)&#123;<br>                    ptr_pre = ptr;<br>                    ptr = ptr-&gt;next;<br>                &#125;<br>                <span class="hljs-comment">// 插入元素并维护cur指针</span><br>                <span class="hljs-keyword">auto</span> next = cur-&gt;next;<br>                ptr_pre-&gt;next = cur;<br>                cur-&gt;next = ptr;<br>                prev-&gt;next = next;<br>                cur = next;<br>            &#125;<br>        &#125;<br>        head = nhead-&gt;next;<br>        <span class="hljs-keyword">delete</span> nhead;        <span class="hljs-comment">// 删除虚拟头结点</span><br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h2 id="归并排序merge-sort">归并排序(Merge Sort)</h2><p>题目来源：<a href="https://leetcode.com/problems/sort-list/">Leetcode-148.Sort List</a></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Sort a linked list in <em>O</em>(<em>n</em> log <em>n</em>) time using constant space complexity.</p><p>样例1：</p><p><strong>Input:</strong> <code>4-&gt;2-&gt;1-&gt;3</code></p><p><strong>Output:</strong> <code>1-&gt;2-&gt;3-&gt;4</code></p><p>样例2：</p><p><strong>Input:</strong> <code>-1-&gt;5-&gt;3-&gt;4-&gt;0</code></p><p><strong>Output:</strong> <code>-1-&gt;0-&gt;3-&gt;4-&gt;5</code></p><h3 id="自底向上">自底向上</h3><p>  <strong>自底向上(Bottom-Up)</strong>的思路与自顶向下的思路相反。自顶向下是将表不断二分，直到每个子表剩下一个元素，然后再向上归并。二自底向上则是从单个元素不断归并，从一到二， 从二到四。直到恢复成一个有序表。</p><p>  以下AC代码使用了栈作为辅助空间。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(n)</span><br><span class="hljs-comment">// 由于使用辅助空间，所以空间复杂度为O(n)。注：数组的归并排序也使用辅助空间。</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 归并两个有序的链表并返回</span><br>    <span class="hljs-comment">// 定义只有一个结点或没有结点的链表是有序的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode *h1, ListNode * h2)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(! h1 &amp;&amp; !h2) <span class="hljs-keyword">return</span> h1;<br>        <span class="hljs-keyword">if</span>(! h1) <span class="hljs-keyword">return</span> h2;<br>        <span class="hljs-keyword">if</span>(! h2) <span class="hljs-keyword">return</span> h1;<br>        <span class="hljs-keyword">auto</span> nhead = h1-&gt;val &lt; h2-&gt;val ? h1 : h2;<br>        <span class="hljs-keyword">if</span>(nhead == h1) h1 = h1-&gt;next;<br>        <span class="hljs-keyword">else</span> h2 = h2-&gt;next;<br>        <span class="hljs-keyword">auto</span> cur = nhead;<br>        <span class="hljs-keyword">while</span>(h1 &amp;&amp; h2)&#123;<br>            <span class="hljs-keyword">if</span>(h1-&gt;val &lt; h2-&gt;val)&#123;<br>                cur-&gt;next = h1;<br>                h1 = h1-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                cur-&gt;next = h2;<br>                h2 = h2-&gt;next;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(h1) cur-&gt;next = h1;<br>        <span class="hljs-keyword">else</span> cur-&gt;next = h2;<br>        <span class="hljs-keyword">return</span> nhead;<br>    &#125;<br>    <span class="hljs-comment">// 对链表进行自底向上的归并排序</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> head;<br>        stack&lt;ListNode*&gt; stk, hstk;<br>        <span class="hljs-comment">// 将所有结点装入辅助栈</span><br>        <span class="hljs-keyword">while</span>(head)&#123;<br>            <span class="hljs-keyword">auto</span> next = head-&gt;next;<br>            head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            stk.<span class="hljs-built_in">push</span>(head);<br>            head = next;<br>        &#125;<br>        <span class="hljs-comment">// 当栈内链表数大于2 还可以归并</span><br>        <span class="hljs-comment">// 否则归并完成</span><br>        <span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-comment">// 实现两两归并</span><br>                <span class="hljs-keyword">if</span>(stk.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)&#123;<br>                    hstk.<span class="hljs-built_in">push</span>(stk.<span class="hljs-built_in">top</span>());<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">auto</span> h1 = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">auto</span> h2 = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">merge</span>(h1, h2);<br>                    hstk.<span class="hljs-built_in">push</span>(h);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(!hstk.<span class="hljs-built_in">empty</span>())&#123;<br>                stk.<span class="hljs-built_in">push</span>(hstk.<span class="hljs-built_in">top</span>());<br>                hstk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="自顶向下">自顶向下</h3><p>  使用「自顶向下」的思路和归并排序的数组实现方式非常类似，我们需要找到链表的中间结点。这里用了一个trick，用两个指针：slow和fast，slow每次指向后继，而fast指向后继的后继，直到fast到达链表尾处，slow的后继就是中间结点。然后就容易实现对链表的归并排序</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(nlogn)</span><br><span class="hljs-comment">// memory: O(logn) 递归的深度是logn</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 归并两个有序的链表并返回</span><br>    <span class="hljs-comment">// 定义只有一个结点或没有结点的链表是有序的</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode *h1, ListNode * h2)</span></span>&#123;<br>        <span class="hljs-comment">//... 同上</span><br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>        ListNode *slow = head, * fast = head-&gt;next;<br>        <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        fast = slow-&gt;next;<br>        slow-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(fast));<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="链表反转">链表反转</h1><h2 id="题目-1">题目</h2><p>题目来源：<a href="https://leetcode.com/problems/reverse-linked-list/">Leetcode-206.Reverse Linked List</a></p><p><strong>Facebook</strong>；<strong>Microsoft</strong>；<strong>Amazon</strong>；<strong>Apple</strong>；<strong>Uber</strong>；<strong>Bloomberg</strong>；</p><p><strong>Twitter</strong>；<strong>Yahoo</strong>；<strong>Zenefits</strong>；<strong>Snapchat</strong>；<strong>Adobe</strong>；<strong>Yelp</strong></p><p>题目难度：<strong>Easy</strong></p><p>题目描述：Reverse a singly linked list.</p><p>样例：</p><p><strong>Input:</strong> <code>1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</code></p><p><strong>Output:</strong> <code>5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></p><p>题目大意：给定一个链表，改变链表结点原有指向使其反转，返回反转后的链表头指针。</p><h3 id="解法1">解法1</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"> * Definition <span class="hljs-keyword">for</span> singly-linked list.<br> * <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> &#123;</span><br> *     <span class="hljs-keyword">int</span> val;<br> *     ListNode *next;<br> *     <span class="hljs-built_in">ListNode</span>(<span class="hljs-keyword">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br> * &#125;;<br> */<br><br><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* pHead)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用三个指针 当前cur、下一结点next、前驱结点prev</span><br>        ListNode * cur = pHead, * next = <span class="hljs-literal">nullptr</span>, * prev = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> cur;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next)&#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = prev;<br>            prev = cur;<br>            cur = next;<br>        &#125;<br>        cur-&gt;next = prev;<br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="解法2">解法2</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// time: O(n)</span><br><span class="hljs-comment">// memory: O(1)</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br><br>        ListNode *cur = head, *pre = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(cur)&#123;<br>            <span class="hljs-comment">// next的存在依赖于cur是否非空</span><br>            ListNode *next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><hr /><h3 id="相关训练-2">相关训练</h3><table><thead><tr class="header"><th>题目</th><th>题解</th><th>难度</th><th>公司</th></tr></thead><tbody><tr class="odd"><td><a href="https://leetcode.com/problems/reverse-linked-list-ii/">Leetcode-92.Reverse Linked List II</a></td><td><a href="https://github.com/yangyangu/MyLeetCode/blob/master/092-reverse-linked-list-ii/reverse-linked-list-ii.cpp">C++</a></td><td><strong>Medium</strong></td><td></td></tr></tbody></table><h1 id="哈希表">哈希表</h1><p>  之前面试腾讯的时候，面试官出过LRU的题，一开始我的解法很朴素：用双链表解决，但是显然这样查找的复杂度为<span class="math inline">\(O(n)\)</span>。怎么优化呢？面试官提示道：如果要<span class="math inline">\(O(1)\)</span>查找，那答案只有一个了吧？我瞬间惊呼：用哈希表。</p><h2 id="题目-2">题目</h2><p>  注意：现在这题如果不用哈希表优化，可能会TLE。</p><p>题目来源：<a href="https://leetcode.com/problems/lru-cache/">Leetcode-146.LRU缓存机制</a></p><p><strong>ByteDance</strong></p><p>题目难度：<strong>Medium</strong></p><p>题目描述：Design and implement a data structure for <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU">Least Recently Used (LRU) cache</a>. It should support the following operations: <code>get</code> and <code>put</code>.</p><p><code>get(key)</code> - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br /><code>put(key, value)</code> - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a <strong>positive</strong> capacity.</p><p>样例：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">LRUCache cache = new LRUCache( 2 /* capacity */ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br></code></pre></div></td></tr></table></figure><h3 id="代码-3">代码</h3><p>  这个代码有点瑕疵，用了好多特判。后续会改一下。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>&#123;</span><br>    <span class="hljs-keyword">int</span> key, value;<br>    Node * next, * prev;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> _k, <span class="hljs-keyword">int</span> _v): <span class="hljs-built_in">key</span>(_k), <span class="hljs-built_in">value</span>(_v), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">prev</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">int</span> size;<br>    Node * head, * tail;<br>    map&lt;<span class="hljs-keyword">int</span>, Node *&gt; mpt;<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> capacity) &#123;<br>        <span class="hljs-keyword">this</span>-&gt;capacity = capacity;<br>        <span class="hljs-keyword">this</span>-&gt;head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">this</span>-&gt;tail = <span class="hljs-keyword">this</span>-&gt;head;<br>        <span class="hljs-keyword">this</span>-&gt;size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">auto</span> node = mpt[key];<br>        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>)&#123;<br><br>            <span class="hljs-keyword">if</span>(size == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> node-&gt;value;<br>            <span class="hljs-keyword">if</span>(tail == node) tail = tail-&gt;prev;<br>            <span class="hljs-keyword">auto</span> prev = node-&gt;prev, next = node-&gt;next;<br>            <span class="hljs-keyword">if</span>(next) next-&gt;prev = prev;<br>            prev-&gt;next = next;<br><br>            node-&gt;next = head-&gt;next;<br>            head-&gt;next-&gt;prev = node;<br>            node-&gt;prev = head;<br>            head-&gt;next = node;<br>            <span class="hljs-keyword">return</span> node-&gt;value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">get</span>(key) != <span class="hljs-number">-1</span>)&#123;<br>            <span class="hljs-keyword">auto</span> node = mpt[key];<br>            node-&gt;value = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(size &gt;= capacity)&#123;<br>            <span class="hljs-keyword">auto</span> last = tail;<br>            tail = tail-&gt;prev;<br>            tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            last-&gt;prev = <span class="hljs-literal">nullptr</span>;<br>            <br>            -- size;<br>            mpt[last-&gt;key] = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-built_in"><span class="hljs-keyword">delete</span></span>(last);<br>        &#125;<br>        Node *node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(key, value);<br>        <span class="hljs-keyword">if</span>(tail == head)&#123;<br>            head-&gt;next = node;<br>            node-&gt;prev = head;<br>            tail = head-&gt;next;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            node-&gt;next = head-&gt;next;<br>            head-&gt;next-&gt;prev = node;<br>            head-&gt;next = node;<br>            node-&gt;prev = head;<br>        &#125;<br>        ++ size;<br>        mpt[key] = node;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your LRUCache object will be instantiated and called as such:</span><br><span class="hljs-comment"> * LRUCache* obj = new LRUCache(capacity);</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;get(key);</span><br><span class="hljs-comment"> * obj-&gt;put(key,value);</span><br><span class="hljs-comment"> */</span><br><br></code></pre></div></td></tr></table></figure><h1 id="检测环">检测环</h1><p>  核心思想：用fast和slow两个指针，fast每次跑两步，slow每次跑一步。如果链表存在环，则最终fast会与slow相遇。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode * root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(! root || ! root-&gt;next)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">auto</span> slow = root, fast = root, prev = root;<br>    <span class="hljs-keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)&#123;<br>            prev = root;<br>            <span class="hljs-keyword">while</span>(prev != slow)&#123;<br>                prev = prev-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="其他">其他</h1><p>  有时候可能需要自己在本地IDE里写题，下面给出一些在IDE的操作技巧（基于C++）。</p><h2 id="链表结构体">链表结构体</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>&#123;</span><br>    <span class="hljs-keyword">int</span> val;<br>    ListNode * next;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span>: val(x), next(nullptr)&#123;</span>&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="创建单链表">创建单链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">ListNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; &amp;arr)</span></span>&#123;<br>    <span class="hljs-keyword">auto</span> root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>), cur = root;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;it: arr)&#123;<br>        cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(it);<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> root-&gt;next;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="打印链表">打印链表</h2><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(ListNode *root)</span></span>&#123;<br>    ListNode * cur = root;<br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        cout &lt;&lt; cur-&gt;val;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next)<br>            cout &lt;&lt; <span class="hljs-string">&quot;-&gt;&quot;</span>;<br>        cur = cur-&gt;next;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>双指针</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的博客记录</title>
    <link href="/2022/03/09/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/03/09/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<em>就在刚才，我删掉了之前写的博客。</em><p align="right">——作者</p><p>  2018年初至今，我写了大约52篇文章，大部分都是关于LeetCode题解的。有一些类型的题目我刷了很多，每一题都单独成篇，可惜自己觉得写出来的东西确实没有什么干货，干脆直接删除了。BTW，这是我的<a href="https://leetcode-cn.com/u/yangyangu/">LeetCode</a>。除了题解，我还写了一些大数据、深度学习的文章，但也都是废话。</p><p>  大约在2017年，我开始断断续续学习编程。不可否认的是，教计算思维的大学老师讲得很好，带我入了C语言的门，但是可惜，我写代码还是很艰辛。后来有一个直系学长推荐了LeetCode等众多OJ，以及我自己在很多在线学习的网站学了很长一段时间的算法、数据结构和C++（这些课程的老师好好反思自己的念PPT课堂），这里要特别感谢<a href="https://github.com/liuyubobobo">liuyubobobo</a>老师。当然，这些都是后话了。</p><p>  然后，终于可以顺利地用编程语言描述自己的想法了，写LeetCode自然是越写越顺心，哪怕是碰到Medium以上的题目，也是可以慢慢摸索出来的（<del>实在不行还有题解</del>）。</p><p>  不过，再往后，LeetCode上的题目也越来越不像是面试题了，更像是算法竞赛的水题/中等题。时至今日，甚至出现了让OI退役选手都惊讶的算法题。我理解，随着求职市场内卷化程度剧增，这种情况是不可避免的。</p><p>  当年的博客里，我主要完成以下类型的题目：</p><ul><li>回溯</li><li>双指针</li><li>搜索</li><li>二叉树</li><li>链表</li><li>动态规划</li><li>贪心</li><li>队列</li><li>数学</li><li>排序</li><li>二分</li><li>图</li></ul><p>  当然，这些类型的题，如果能熟练掌握（Bug-free、最优解法、默写），无论是找工作面试还是其他算法考试，都足以应对了。哈哈，我确实还不太能做到<em>熟练掌握</em>。我承认之前写的博客都是在水文字，把题目大意、思路和代码放上去，质量真的不高。讲真，就连我自己也很少去翻之前写的东西。</p><p>  有一说一，之前写的文章，放在简历里还是可以的。虽然没法唬住面试官，但是至少能增加一点对面试者的好感，至少ta会严谨的对待自己的学习，哪怕学的东西很基础。这或许是我写博客的初衷——把博客做成一个长期的简历。</p><p>  未来我的想法是：把文章精简化。譬如说，在刷题的文章里，我希望能过通过一道题来解决一类题，学会这道题背后的算法思想，而不只是Accepted这一道题。在其他类型的文章里，也应该能做到类似的事情。</p><p>  因此，我会把之前删掉的文章整合成质量更高的合集（<del>哈哈不是删除了嘛</del>）。希望能让自己更深入的理解其中的思想。</p><p>  最近刷题的主战场在<a href="https://www.acwing.com/">AcWing</a>，一句话：y总YYDS！目前，我希望学好以下类型的题目：</p><ul><li>基础数据结构模板</li><li>树状数组、线段树、Trie、UnionFind、AC自动机...</li><li>各种类型的DP</li><li>搜索优化</li><li>前缀、差分、位运算</li><li>...</li></ul><p>  大家加油！</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>献给自己</title>
    <link href="/2022/03/09/%E7%8C%AE%E7%BB%99%E8%87%AA%E5%B7%B1/"/>
    <url>/2022/03/09/%E7%8C%AE%E7%BB%99%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p><em>  很长一段时间，我的生活看似马上就要开始了，真正的生活，但是总是有一些阻碍阻拦着，有些事得先解决，有些工作待完成，时间貌似够用，还有一笔债务要去付清，然后生活就会开始。</em></p><p><em>  最后我终于明白，这些障碍，正是我的生活。</em></p><p align="right">——艾弗里德·德索萨</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
